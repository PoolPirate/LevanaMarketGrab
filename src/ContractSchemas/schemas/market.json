{
  "contract_name": "market",
  "contract_version": "0.1.0-beta.15",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The InstantiateMsg comes from Factory only",
    "type": "object",
    "required": [
      "factory",
      "initial_borrow_fee_rate",
      "market_id",
      "spot_price",
      "token"
    ],
    "properties": {
      "config": {
        "description": "Modifications to the default config value",
        "anyOf": [
          {
            "$ref": "#/definitions/ConfigUpdate"
          },
          {
            "type": "null"
          }
        ]
      },
      "factory": {
        "description": "The factory address",
        "allOf": [
          {
            "$ref": "#/definitions/RawAddr"
          }
        ]
      },
      "initial_borrow_fee_rate": {
        "description": "Initial borrow fee rate when launching the protocol, annualized",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal256"
          }
        ]
      },
      "initial_price": {
        "description": "Initial price to use in the contract\n\nThis is required when doing manual price updates, and prohibited for oracle based price updates. It would make more sense to include this in [SpotPriceConfigInit], but that will create more complications in config update logic.",
        "anyOf": [
          {
            "$ref": "#/definitions/InitialPrice"
          },
          {
            "type": "null"
          }
        ]
      },
      "market_id": {
        "description": "Base, quote, and market type",
        "allOf": [
          {
            "$ref": "#/definitions/MarketId"
          }
        ]
      },
      "spot_price": {
        "description": "Mandatory spot price config",
        "allOf": [
          {
            "$ref": "#/definitions/SpotPriceConfigInit"
          }
        ]
      },
      "token": {
        "description": "The token used for collateral",
        "allOf": [
          {
            "$ref": "#/definitions/TokenInit"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "ConfigUpdate": {
        "description": "Helper struct to conveniently update [Config]\n\nFor each field below, please see the corresponding [Config] field's documentation.",
        "type": "object",
        "properties": {
          "borrow_fee_rate_max_annualized": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "borrow_fee_rate_min_annualized": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "borrow_fee_sensitivity": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "carry_leverage": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "crank_execs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "crank_fee_charged": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "crank_fee_reward": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "crank_fee_surcharge": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "delta_neutrality_fee_cap": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "delta_neutrality_fee_sensitivity": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "delta_neutrality_fee_tax": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "disable_position_nft_exec": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "exposure_margin_ratio": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "funding_rate_max_annualized": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "funding_rate_sensitivity": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "liquidity_cooldown_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "liquifunding_delay_fuzz_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "liquifunding_delay_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "max_leverage": {
            "description": "\n            A signed number type with high fidelity.\n            Similar in spirit to cosmwasm_bignumber::Decimal256 - it is\n            a more ergonomic wrapper around cosmwasm-std by making more things public\n            but we also add negative values and other methods as-needed\n        ",
            "type": [
              "string",
              "null"
            ]
          },
          "max_liquidity": {
            "anyOf": [
              {
                "$ref": "#/definitions/MaxLiquidity"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_xlp_rewards_multiplier": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "min_xlp_rewards_multiplier": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "minimum_deposit_usd": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "mute_events": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "protocol_tax": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "spot_price": {
            "anyOf": [
              {
                "$ref": "#/definitions/SpotPriceConfigInit"
              },
              {
                "type": "null"
              }
            ]
          },
          "target_utilization": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "trading_fee_counter_collateral": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "trading_fee_notional_size": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "unstake_period_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Decimal256": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
        "type": "string"
      },
      "Identifier": {
        "type": "string"
      },
      "InitialPrice": {
        "description": "Initial price when instantiating a contract",
        "type": "object",
        "required": [
          "price",
          "price_usd"
        ],
        "properties": {
          "price": {
            "description": "Price of base in terms of quote",
            "allOf": [
              {
                "$ref": "#/definitions/PriceBaseInQuote"
              }
            ]
          },
          "price_usd": {
            "description": "Price of collateral in terms of USD",
            "allOf": [
              {
                "$ref": "#/definitions/PriceCollateralInUsd"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "MarketId": {
        "type": "string",
        "format": "market-id"
      },
      "MaxLiquidity": {
        "description": "Maximum liquidity for deposit.\n\nNote that this limit can be exceeded due to changes in collateral asset price or impairment.",
        "oneOf": [
          {
            "description": "No bounds on how much liquidity can be deposited.",
            "type": "object",
            "required": [
              "unlimited"
            ],
            "properties": {
              "unlimited": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Only allow the given amount in USD.\n\nThe exchange rate at time of deposit will be used.",
            "type": "object",
            "required": [
              "usd"
            ],
            "properties": {
              "usd": {
                "type": "object",
                "required": [
                  "amount"
                ],
                "properties": {
                  "amount": {
                    "description": "Amount in USD",
                    "allOf": [
                      {
                        "$ref": "#/definitions/NonZero decimal"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "NonZero decimal": {
        "type": "string",
        "format": "non-zero"
      },
      "PriceBaseInQuote": {
        "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
        "allOf": [
          {
            "$ref": "#/definitions/NonZero decimal"
          }
        ]
      },
      "PriceCollateralInUsd": {
        "description": "PriceBaseInQuote converted to USD",
        "allOf": [
          {
            "$ref": "#/definitions/NonZero decimal"
          }
        ]
      },
      "PythConfigInit": {
        "description": "Configuration for pyth init messages",
        "type": "object",
        "required": [
          "contract_address",
          "network"
        ],
        "properties": {
          "contract_address": {
            "description": "The address of the pyth oracle contract",
            "allOf": [
              {
                "$ref": "#/definitions/RawAddr"
              }
            ]
          },
          "network": {
            "description": "Which network to use for the price service This isn't used for any internal logic, but clients must use the appropriate price service endpoint to match this",
            "allOf": [
              {
                "$ref": "#/definitions/PythPriceServiceNetwork"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PythPriceServiceNetwork": {
        "description": "Which network to use for the price service",
        "oneOf": [
          {
            "description": "Stable CosmWasm\n\nFrom <https://pyth.network/developers/price-feed-ids#cosmwasm-stable>",
            "type": "string",
            "enum": [
              "stable"
            ]
          },
          {
            "description": "Edge CosmWasm\n\nFrom <https://pyth.network/developers/price-feed-ids#cosmwasm-edge>",
            "type": "string",
            "enum": [
              "edge"
            ]
          }
        ]
      },
      "RawAddr": {
        "description": "A raw address passed in via JSON.\n\nThe purpose of this newtype wrapper is to make it clear at the type level if a parameter is an address, and ensure that we go through a proper validation step when using it.",
        "type": "string"
      },
      "SpotPriceConfigInit": {
        "description": "Spot price config for initialization messages",
        "oneOf": [
          {
            "description": "Manual spot price",
            "type": "object",
            "required": [
              "manual"
            ],
            "properties": {
              "manual": {
                "type": "object",
                "required": [
                  "admin"
                ],
                "properties": {
                  "admin": {
                    "description": "The admin address for manual spot price updates",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "External oracle",
            "type": "object",
            "required": [
              "oracle"
            ],
            "properties": {
              "oracle": {
                "type": "object",
                "required": [
                  "feeds",
                  "feeds_usd"
                ],
                "properties": {
                  "feeds": {
                    "description": "sequence of spot price feeds which are composed to generate a single spot price",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/SpotPriceFeedInit"
                    }
                  },
                  "feeds_usd": {
                    "description": "if necessary, sequence of spot price feeds which are composed to generate a single USD spot price",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/SpotPriceFeedInit"
                    }
                  },
                  "pyth": {
                    "description": "Pyth configuration, required on chains that use pyth feeds",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/PythConfigInit"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "stride": {
                    "description": "Stride configuration, required on chains that use stride feeds",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/StrideConfigInit"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "volatile_diff_seconds": {
                    "description": "See [SpotPriceConfig::volatile_diff_seconds]",
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SpotPriceFeedDataInit": {
        "description": "The data for an individual spot price feed",
        "oneOf": [
          {
            "description": "Hardcoded value",
            "type": "object",
            "required": [
              "constant"
            ],
            "properties": {
              "constant": {
                "type": "object",
                "required": [
                  "price"
                ],
                "properties": {
                  "price": {
                    "description": "The constant price",
                    "allOf": [
                      {
                        "$ref": "#/definitions/NonZero decimal"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Pyth price feeds",
            "type": "object",
            "required": [
              "pyth"
            ],
            "properties": {
              "pyth": {
                "type": "object",
                "required": [
                  "age_tolerance_seconds",
                  "id"
                ],
                "properties": {
                  "age_tolerance_seconds": {
                    "description": "price age tolerance, in seconds",
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "id": {
                    "description": "The identifier on pyth",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Identifier"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stride liquid staking",
            "type": "object",
            "required": [
              "stride"
            ],
            "properties": {
              "stride": {
                "type": "object",
                "required": [
                  "age_tolerance_seconds",
                  "denom"
                ],
                "properties": {
                  "age_tolerance_seconds": {
                    "description": "price age tolerance, in seconds",
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "denom": {
                    "description": "The IBC denom for the asset",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native oracle module on the sei chain",
            "type": "object",
            "required": [
              "sei"
            ],
            "properties": {
              "sei": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "description": "The denom to use",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Simple contract with a QueryMsg::Price call",
            "type": "object",
            "required": [
              "simple"
            ],
            "properties": {
              "simple": {
                "type": "object",
                "required": [
                  "age_tolerance_seconds",
                  "contract"
                ],
                "properties": {
                  "age_tolerance_seconds": {
                    "description": "price age tolerance, in seconds",
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "contract": {
                    "description": "The contract to use",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SpotPriceFeedInit": {
        "description": "An individual feed used to compose a final spot price",
        "type": "object",
        "required": [
          "data",
          "inverted"
        ],
        "properties": {
          "data": {
            "description": "The data for this price feed",
            "allOf": [
              {
                "$ref": "#/definitions/SpotPriceFeedDataInit"
              }
            ]
          },
          "inverted": {
            "description": "is this price feed inverted",
            "type": "boolean"
          },
          "volatile": {
            "description": "See [SpotPriceFeed::volatile]",
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "StrideConfigInit": {
        "description": "Configuration for stride",
        "type": "object",
        "required": [
          "contract_address"
        ],
        "properties": {
          "contract_address": {
            "description": "The address of the redemption rate contract",
            "allOf": [
              {
                "$ref": "#/definitions/RawAddr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "TokenInit": {
        "description": "The number of decimal places for tokens may vary and there is a smart query cost for deriving it at runtime so we grab the info at init time and then store it as a full-fledged token",
        "oneOf": [
          {
            "description": "A cw20 address. Decimal places will be derived.",
            "type": "object",
            "required": [
              "cw20"
            ],
            "properties": {
              "cw20": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "description": "Address of the CW20 contract",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native currency. May cover some IBC tokens too",
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "type": "object",
                "required": [
                  "decimal_places",
                  "denom"
                ],
                "properties": {
                  "decimal_places": {
                    "description": "Number of decimal points",
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0.0
                  },
                  "denom": {
                    "description": "Denom used within the chain for this native coin",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Usd": {
        "description": "Unsigned value",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal256"
          }
        ]
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "Execute message for the market contract",
    "oneOf": [
      {
        "description": "Owner-only executions",
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "$ref": "#/definitions/ExecuteOwnerMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "cw20",
        "type": "object",
        "required": [
          "receive"
        ],
        "properties": {
          "receive": {
            "type": "object",
            "required": [
              "amount",
              "msg",
              "sender"
            ],
            "properties": {
              "amount": {
                "description": "Amount of funds sent",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "msg": {
                "description": "Must parse to a [ExecuteMsg]",
                "allOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  }
                ]
              },
              "sender": {
                "description": "Owner of funds sent to the contract",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Open a new position",
        "type": "object",
        "required": [
          "open_position"
        ],
        "properties": {
          "open_position": {
            "type": "object",
            "required": [
              "direction",
              "leverage",
              "max_gains"
            ],
            "properties": {
              "direction": {
                "description": "Direction of new position",
                "allOf": [
                  {
                    "$ref": "#/definitions/DirectionToBase"
                  }
                ]
              },
              "leverage": {
                "description": "Leverage of new position",
                "allOf": [
                  {
                    "$ref": "#/definitions/LeverageToBase"
                  }
                ]
              },
              "max_gains": {
                "description": "Maximum gains of new position",
                "allOf": [
                  {
                    "$ref": "#/definitions/MaxGainsInQuote"
                  }
                ]
              },
              "slippage_assert": {
                "description": "Assertion that the price has not moved too far",
                "anyOf": [
                  {
                    "$ref": "#/definitions/SlippageAssert"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "stop_loss_override": {
                "description": "Stop loss price of new position",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "take_profit_override": {
                "description": "Take profit price of new position",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add collateral to a position, causing leverage to decrease\n\nThe amount of collateral to add must be attached as funds",
        "type": "object",
        "required": [
          "update_position_add_collateral_impact_leverage"
        ],
        "properties": {
          "update_position_add_collateral_impact_leverage": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "description": "ID of position to update",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add collateral to a position, causing notional size to increase\n\nThe amount of collateral to add must be attached as funds",
        "type": "object",
        "required": [
          "update_position_add_collateral_impact_size"
        ],
        "properties": {
          "update_position_add_collateral_impact_size": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "description": "ID of position to update",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "slippage_assert": {
                "description": "Assertion that the price has not moved too far",
                "anyOf": [
                  {
                    "$ref": "#/definitions/SlippageAssert"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove collateral from a position, causing leverage to increase",
        "type": "object",
        "required": [
          "update_position_remove_collateral_impact_leverage"
        ],
        "properties": {
          "update_position_remove_collateral_impact_leverage": {
            "type": "object",
            "required": [
              "amount",
              "id"
            ],
            "properties": {
              "amount": {
                "description": "Amount of funds to remove from the position",
                "allOf": [
                  {
                    "$ref": "#/definitions/NonZero decimal"
                  }
                ]
              },
              "id": {
                "description": "ID of position to update",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove collateral from a position, causing notional size to decrease",
        "type": "object",
        "required": [
          "update_position_remove_collateral_impact_size"
        ],
        "properties": {
          "update_position_remove_collateral_impact_size": {
            "type": "object",
            "required": [
              "amount",
              "id"
            ],
            "properties": {
              "amount": {
                "description": "Amount of funds to remove from the position",
                "allOf": [
                  {
                    "$ref": "#/definitions/NonZero decimal"
                  }
                ]
              },
              "id": {
                "description": "ID of position to update",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "slippage_assert": {
                "description": "Assertion that the price has not moved too far",
                "anyOf": [
                  {
                    "$ref": "#/definitions/SlippageAssert"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Modify the leverage of the position\n\nThis will impact the notional size of the position",
        "type": "object",
        "required": [
          "update_position_leverage"
        ],
        "properties": {
          "update_position_leverage": {
            "type": "object",
            "required": [
              "id",
              "leverage"
            ],
            "properties": {
              "id": {
                "description": "ID of position to update",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "leverage": {
                "description": "New leverage of the position",
                "allOf": [
                  {
                    "$ref": "#/definitions/LeverageToBase"
                  }
                ]
              },
              "slippage_assert": {
                "description": "Assertion that the price has not moved too far",
                "anyOf": [
                  {
                    "$ref": "#/definitions/SlippageAssert"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Modify the max gains of a position",
        "type": "object",
        "required": [
          "update_position_max_gains"
        ],
        "properties": {
          "update_position_max_gains": {
            "type": "object",
            "required": [
              "id",
              "max_gains"
            ],
            "properties": {
              "id": {
                "description": "ID of position to update",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "max_gains": {
                "description": "New max gains of the position",
                "allOf": [
                  {
                    "$ref": "#/definitions/MaxGainsInQuote"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set a stop loss or take profit override. This msg will override any previous values. Passing None will remove the override.",
        "type": "object",
        "required": [
          "set_trigger_order"
        ],
        "properties": {
          "set_trigger_order": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "description": "ID of position to modify",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "stop_loss_override": {
                "description": "New stop loss price of the position",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "take_profit_override": {
                "description": "New take profit price of the position",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set a limit order to open a position when the price of the asset hits the specified trigger price.",
        "type": "object",
        "required": [
          "place_limit_order"
        ],
        "properties": {
          "place_limit_order": {
            "type": "object",
            "required": [
              "direction",
              "leverage",
              "max_gains",
              "trigger_price"
            ],
            "properties": {
              "direction": {
                "description": "Direction of new position",
                "allOf": [
                  {
                    "$ref": "#/definitions/DirectionToBase"
                  }
                ]
              },
              "leverage": {
                "description": "Leverage of new position",
                "allOf": [
                  {
                    "$ref": "#/definitions/LeverageToBase"
                  }
                ]
              },
              "max_gains": {
                "description": "Max gains of new position",
                "allOf": [
                  {
                    "$ref": "#/definitions/MaxGainsInQuote"
                  }
                ]
              },
              "stop_loss_override": {
                "description": "Stop loss price of new position",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "take_profit_override": {
                "description": "Take profit price of new position",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "trigger_price": {
                "description": "Price when the order should trigger",
                "allOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Cancel an open limit order",
        "type": "object",
        "required": [
          "cancel_limit_order"
        ],
        "properties": {
          "cancel_limit_order": {
            "type": "object",
            "required": [
              "order_id"
            ],
            "properties": {
              "order_id": {
                "description": "ID of the order",
                "allOf": [
                  {
                    "$ref": "#/definitions/OrderId"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Close a position",
        "type": "object",
        "required": [
          "close_position"
        ],
        "properties": {
          "close_position": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "description": "ID of position to close",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "slippage_assert": {
                "description": "Assertion that the price has not moved too far",
                "anyOf": [
                  {
                    "$ref": "#/definitions/SlippageAssert"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Deposits send funds into the unlocked liquidity fund Returns [LiquidityDepositResponseData] as response data",
        "type": "object",
        "required": [
          "deposit_liquidity"
        ],
        "properties": {
          "deposit_liquidity": {
            "type": "object",
            "properties": {
              "stake_to_xlp": {
                "description": "Should we stake the resulting LP tokens into xLP?\n\nDefaults to `false`.",
                "default": false,
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Like [ExecuteMsg::DepositLiquidity], but reinvests pending yield instead of receiving new funds.",
        "type": "object",
        "required": [
          "reinvest_yield"
        ],
        "properties": {
          "reinvest_yield": {
            "type": "object",
            "properties": {
              "amount": {
                "description": "Amount of rewards to reinvest.\n\nIf `None`, reinvests all pending rewards.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/NonZero decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "stake_to_xlp": {
                "description": "Should we stake the resulting LP tokens into xLP?\n\nDefaults to `false`.",
                "default": false,
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw liquidity calculated from specified `lp_amount`",
        "type": "object",
        "required": [
          "withdraw_liquidity"
        ],
        "properties": {
          "withdraw_liquidity": {
            "type": "object",
            "properties": {
              "lp_amount": {
                "description": "Amount of LP tokens to burn",
                "anyOf": [
                  {
                    "$ref": "#/definitions/NonZero decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claims accrued yield based on LP share allocation",
        "type": "object",
        "required": [
          "claim_yield"
        ],
        "properties": {
          "claim_yield": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Stake some existing LP tokens into xLP\n\n[None] means stake all LP tokens.",
        "type": "object",
        "required": [
          "stake_lp"
        ],
        "properties": {
          "stake_lp": {
            "type": "object",
            "properties": {
              "amount": {
                "description": "Amount of LP tokens to convert into xLP.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/NonZero decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Begin unstaking xLP into LP\n\n[None] means unstake all xLP tokens.",
        "type": "object",
        "required": [
          "unstake_xlp"
        ],
        "properties": {
          "unstake_xlp": {
            "type": "object",
            "properties": {
              "amount": {
                "description": "Amount of xLP tokens to convert into LP",
                "anyOf": [
                  {
                    "$ref": "#/definitions/NonZero decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Stop an ongoing xLP unstaking process.",
        "type": "object",
        "required": [
          "stop_unstaking_xlp"
        ],
        "properties": {
          "stop_unstaking_xlp": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Collect any LP tokens that have been unstaked from xLP.",
        "type": "object",
        "required": [
          "collect_unstaked_lp"
        ],
        "properties": {
          "collect_unstaked_lp": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Crank a number of times",
        "type": "object",
        "required": [
          "crank"
        ],
        "properties": {
          "crank": {
            "type": "object",
            "properties": {
              "execs": {
                "description": "Total number of crank executions to do None: config default",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "rewards": {
                "description": "Which wallet receives crank rewards.\n\nIf unspecified, sender receives the rewards.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Nft proxy messages. Only allowed to be called by this market's position_token contract",
        "type": "object",
        "required": [
          "nft_proxy"
        ],
        "properties": {
          "nft_proxy": {
            "type": "object",
            "required": [
              "msg",
              "sender"
            ],
            "properties": {
              "msg": {
                "description": "Message sent to the NFT proxy",
                "allOf": [
                  {
                    "$ref": "#/definitions/ExecuteMsg"
                  }
                ]
              },
              "sender": {
                "description": "Original caller of the NFT proxy.",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "liquidity token cw20 proxy messages. Only allowed to be called by this market's liquidity_token contract",
        "type": "object",
        "required": [
          "liquidity_token_proxy"
        ],
        "properties": {
          "liquidity_token_proxy": {
            "type": "object",
            "required": [
              "kind",
              "msg",
              "sender"
            ],
            "properties": {
              "kind": {
                "description": "Whether this was the LP or xLP proxy.",
                "allOf": [
                  {
                    "$ref": "#/definitions/LiquidityTokenKind"
                  }
                ]
              },
              "msg": {
                "description": "Message sent to the liquidity token proxy.",
                "allOf": [
                  {
                    "$ref": "#/definitions/ExecuteMsg"
                  }
                ]
              },
              "sender": {
                "description": "Original caller of the liquidity token proxy.",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Transfer all available protocol fees to the dao account",
        "type": "object",
        "required": [
          "transfer_dao_fees"
        ],
        "properties": {
          "transfer_dao_fees": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Begin force-closing all positions in the protocol.\n\nThis can only be performed by the market wind down wallet.",
        "type": "object",
        "required": [
          "close_all_positions"
        ],
        "properties": {
          "close_all_positions": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Provide funds directly to the crank fees.\n\nThe person who calls this receives no benefits. It's intended for the DAO to use to incentivize cranking.",
        "type": "object",
        "required": [
          "provide_crank_funds"
        ],
        "properties": {
          "provide_crank_funds": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set manual price (mostly for testing)",
        "type": "object",
        "required": [
          "set_manual_price"
        ],
        "properties": {
          "set_manual_price": {
            "type": "object",
            "required": [
              "price",
              "price_usd"
            ],
            "properties": {
              "price": {
                "description": "Price of the base asset in terms of the quote.",
                "allOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  }
                ]
              },
              "price_usd": {
                "description": "Price of the collateral asset in terms of USD.\n\nThis is generally used for reporting of values like PnL and trade volume.",
                "allOf": [
                  {
                    "$ref": "#/definitions/PriceCollateralInUsd"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Perform a deferred exec\n\nThis should only ever be called from the market contract itself, any other call is guaranteed to fail.",
        "type": "object",
        "required": [
          "perform_deferred_exec"
        ],
        "properties": {
          "perform_deferred_exec": {
            "type": "object",
            "required": [
              "id",
              "price_point_timestamp"
            ],
            "properties": {
              "id": {
                "description": "Which ID to execute",
                "allOf": [
                  {
                    "$ref": "#/definitions/DeferredExecId"
                  }
                ]
              },
              "price_point_timestamp": {
                "description": "Which price point to use for this execution.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "ConfigUpdate": {
        "description": "Helper struct to conveniently update [Config]\n\nFor each field below, please see the corresponding [Config] field's documentation.",
        "type": "object",
        "properties": {
          "borrow_fee_rate_max_annualized": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "borrow_fee_rate_min_annualized": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "borrow_fee_sensitivity": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "carry_leverage": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "crank_execs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "crank_fee_charged": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "crank_fee_reward": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "crank_fee_surcharge": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "delta_neutrality_fee_cap": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "delta_neutrality_fee_sensitivity": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "delta_neutrality_fee_tax": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "disable_position_nft_exec": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "exposure_margin_ratio": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "funding_rate_max_annualized": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "funding_rate_sensitivity": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "liquidity_cooldown_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "liquifunding_delay_fuzz_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "liquifunding_delay_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "max_leverage": {
            "description": "\n            A signed number type with high fidelity.\n            Similar in spirit to cosmwasm_bignumber::Decimal256 - it is\n            a more ergonomic wrapper around cosmwasm-std by making more things public\n            but we also add negative values and other methods as-needed\n        ",
            "type": [
              "string",
              "null"
            ]
          },
          "max_liquidity": {
            "anyOf": [
              {
                "$ref": "#/definitions/MaxLiquidity"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_xlp_rewards_multiplier": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "min_xlp_rewards_multiplier": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "minimum_deposit_usd": {
            "anyOf": [
              {
                "$ref": "#/definitions/Usd"
              },
              {
                "type": "null"
              }
            ]
          },
          "mute_events": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "protocol_tax": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "spot_price": {
            "anyOf": [
              {
                "$ref": "#/definitions/SpotPriceConfigInit"
              },
              {
                "type": "null"
              }
            ]
          },
          "target_utilization": {
            "anyOf": [
              {
                "$ref": "#/definitions/NonZero decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "trading_fee_counter_collateral": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "trading_fee_notional_size": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal256"
              },
              {
                "type": "null"
              }
            ]
          },
          "unstake_period_seconds": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Decimal256": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
        "type": "string"
      },
      "DeferredExecId": {
        "description": "A unique numeric ID for each deferred execution in the protocol.",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "DirectionToBase": {
        "description": "Direction in terms of base",
        "oneOf": [
          {
            "description": "Long versus base",
            "type": "string",
            "enum": [
              "long"
            ]
          },
          {
            "description": "Short versus base",
            "type": "string",
            "enum": [
              "short"
            ]
          }
        ]
      },
      "ExecuteMsg": {
        "description": "Execute messages for a position token proxy\n\nMatches the CW721 standard.",
        "oneOf": [
          {
            "description": "Transfer is a base message to move a token to another account without triggering actions",
            "type": "object",
            "required": [
              "transfer_nft"
            ],
            "properties": {
              "transfer_nft": {
                "type": "object",
                "required": [
                  "recipient",
                  "token_id"
                ],
                "properties": {
                  "recipient": {
                    "description": "Recipient of the NFT (position)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Send is a base message to transfer a token to a contract and trigger an action on the receiving contract.",
            "type": "object",
            "required": [
              "send_nft"
            ],
            "properties": {
              "send_nft": {
                "type": "object",
                "required": [
                  "contract",
                  "msg",
                  "token_id"
                ],
                "properties": {
                  "contract": {
                    "description": "Contract to receive the position",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "msg": {
                    "description": "Message to execute on the contract",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Allows operator to transfer / send the token from the owner's account. If expiration is set, then this allowance has a time/height limit",
            "type": "object",
            "required": [
              "approve"
            ],
            "properties": {
              "approve": {
                "type": "object",
                "required": [
                  "spender",
                  "token_id"
                ],
                "properties": {
                  "expires": {
                    "description": "When the approval expires",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "spender": {
                    "description": "Address that is allowed to spend the NFT",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove previously granted Approval",
            "type": "object",
            "required": [
              "revoke"
            ],
            "properties": {
              "revoke": {
                "type": "object",
                "required": [
                  "spender",
                  "token_id"
                ],
                "properties": {
                  "spender": {
                    "description": "Address that is no longer allowed to spend the NFT",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Allows operator to transfer / send any token from the owner's account. If expiration is set, then this allowance has a time/height limit",
            "type": "object",
            "required": [
              "approve_all"
            ],
            "properties": {
              "approve_all": {
                "type": "object",
                "required": [
                  "operator"
                ],
                "properties": {
                  "expires": {
                    "description": "When the approval expires",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "operator": {
                    "description": "Address that is allowed to spend all NFTs by the sending wallet",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove previously granted ApproveAll permission",
            "type": "object",
            "required": [
              "revoke_all"
            ],
            "properties": {
              "revoke_all": {
                "type": "object",
                "required": [
                  "operator"
                ],
                "properties": {
                  "operator": {
                    "description": "Address that is no longer allowed to spend all NFTs",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ExecuteOwnerMsg": {
        "description": "Owner-only messages",
        "oneOf": [
          {
            "description": "Update the config",
            "type": "object",
            "required": [
              "config_update"
            ],
            "properties": {
              "config_update": {
                "type": "object",
                "required": [
                  "update"
                ],
                "properties": {
                  "update": {
                    "description": "New configuration parameters",
                    "allOf": [
                      {
                        "$ref": "#/definitions/ConfigUpdate"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Identifier": {
        "type": "string"
      },
      "LeverageToBase": {
        "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal256"
          }
        ]
      },
      "LiquidityTokenKind": {
        "description": "The kind of liquidity token",
        "oneOf": [
          {
            "description": "LP token",
            "type": "string",
            "enum": [
              "lp"
            ]
          },
          {
            "description": "xLP token",
            "type": "string",
            "enum": [
              "xlp"
            ]
          }
        ]
      },
      "MaxGainsInQuote": {
        "type": "string",
        "format": "leverage"
      },
      "MaxLiquidity": {
        "description": "Maximum liquidity for deposit.\n\nNote that this limit can be exceeded due to changes in collateral asset price or impairment.",
        "oneOf": [
          {
            "description": "No bounds on how much liquidity can be deposited.",
            "type": "object",
            "required": [
              "unlimited"
            ],
            "properties": {
              "unlimited": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Only allow the given amount in USD.\n\nThe exchange rate at time of deposit will be used.",
            "type": "object",
            "required": [
              "usd"
            ],
            "properties": {
              "usd": {
                "type": "object",
                "required": [
                  "amount"
                ],
                "properties": {
                  "amount": {
                    "description": "Amount in USD",
                    "allOf": [
                      {
                        "$ref": "#/definitions/NonZero decimal"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "NonZero decimal": {
        "type": "string",
        "format": "non-zero"
      },
      "OrderId": {
        "description": "A unique numeric ID for each order in the protocol.",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "PositionId": {
        "description": "PositionId",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "PriceBaseInQuote": {
        "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
        "allOf": [
          {
            "$ref": "#/definitions/NonZero decimal"
          }
        ]
      },
      "PriceCollateralInUsd": {
        "description": "PriceBaseInQuote converted to USD",
        "allOf": [
          {
            "$ref": "#/definitions/NonZero decimal"
          }
        ]
      },
      "PythConfigInit": {
        "description": "Configuration for pyth init messages",
        "type": "object",
        "required": [
          "contract_address",
          "network"
        ],
        "properties": {
          "contract_address": {
            "description": "The address of the pyth oracle contract",
            "allOf": [
              {
                "$ref": "#/definitions/RawAddr"
              }
            ]
          },
          "network": {
            "description": "Which network to use for the price service This isn't used for any internal logic, but clients must use the appropriate price service endpoint to match this",
            "allOf": [
              {
                "$ref": "#/definitions/PythPriceServiceNetwork"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PythPriceServiceNetwork": {
        "description": "Which network to use for the price service",
        "oneOf": [
          {
            "description": "Stable CosmWasm\n\nFrom <https://pyth.network/developers/price-feed-ids#cosmwasm-stable>",
            "type": "string",
            "enum": [
              "stable"
            ]
          },
          {
            "description": "Edge CosmWasm\n\nFrom <https://pyth.network/developers/price-feed-ids#cosmwasm-edge>",
            "type": "string",
            "enum": [
              "edge"
            ]
          }
        ]
      },
      "RawAddr": {
        "description": "A raw address passed in via JSON.\n\nThe purpose of this newtype wrapper is to make it clear at the type level if a parameter is an address, and ensure that we go through a proper validation step when using it.",
        "type": "string"
      },
      "SlippageAssert": {
        "description": "There are two sources of slippage in the protocol: - Change in the oracle price from creation of the message to execution of the message. - Change in delta neutrality fee from creation of the message to execution of the message. Slippage assert tolerance is the tolerance to the sum of the two sources of slippage.",
        "type": "object",
        "required": [
          "price",
          "tolerance"
        ],
        "properties": {
          "price": {
            "description": "Expected effective price from the sender. To incorporate tolerance on delta neutrality fee, the expected price should be modified by expected fee rate: `price = oracle_price * (1 + fee_rate)` `fee_rate` here is the ratio between the delta neutrality fee amount and notional size delta (in collateral asset).",
            "allOf": [
              {
                "$ref": "#/definitions/PriceBaseInQuote"
              }
            ]
          },
          "tolerance": {
            "description": "Max ratio tolerance of actual trade price differing in an unfavorable direction from expected price. Tolerance of 0.01 means max 1% difference.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "SpotPriceConfigInit": {
        "description": "Spot price config for initialization messages",
        "oneOf": [
          {
            "description": "Manual spot price",
            "type": "object",
            "required": [
              "manual"
            ],
            "properties": {
              "manual": {
                "type": "object",
                "required": [
                  "admin"
                ],
                "properties": {
                  "admin": {
                    "description": "The admin address for manual spot price updates",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "External oracle",
            "type": "object",
            "required": [
              "oracle"
            ],
            "properties": {
              "oracle": {
                "type": "object",
                "required": [
                  "feeds",
                  "feeds_usd"
                ],
                "properties": {
                  "feeds": {
                    "description": "sequence of spot price feeds which are composed to generate a single spot price",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/SpotPriceFeedInit"
                    }
                  },
                  "feeds_usd": {
                    "description": "if necessary, sequence of spot price feeds which are composed to generate a single USD spot price",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/SpotPriceFeedInit"
                    }
                  },
                  "pyth": {
                    "description": "Pyth configuration, required on chains that use pyth feeds",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/PythConfigInit"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "stride": {
                    "description": "Stride configuration, required on chains that use stride feeds",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/StrideConfigInit"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "volatile_diff_seconds": {
                    "description": "See [SpotPriceConfig::volatile_diff_seconds]",
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SpotPriceFeedDataInit": {
        "description": "The data for an individual spot price feed",
        "oneOf": [
          {
            "description": "Hardcoded value",
            "type": "object",
            "required": [
              "constant"
            ],
            "properties": {
              "constant": {
                "type": "object",
                "required": [
                  "price"
                ],
                "properties": {
                  "price": {
                    "description": "The constant price",
                    "allOf": [
                      {
                        "$ref": "#/definitions/NonZero decimal"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Pyth price feeds",
            "type": "object",
            "required": [
              "pyth"
            ],
            "properties": {
              "pyth": {
                "type": "object",
                "required": [
                  "age_tolerance_seconds",
                  "id"
                ],
                "properties": {
                  "age_tolerance_seconds": {
                    "description": "price age tolerance, in seconds",
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "id": {
                    "description": "The identifier on pyth",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Identifier"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stride liquid staking",
            "type": "object",
            "required": [
              "stride"
            ],
            "properties": {
              "stride": {
                "type": "object",
                "required": [
                  "age_tolerance_seconds",
                  "denom"
                ],
                "properties": {
                  "age_tolerance_seconds": {
                    "description": "price age tolerance, in seconds",
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "denom": {
                    "description": "The IBC denom for the asset",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native oracle module on the sei chain",
            "type": "object",
            "required": [
              "sei"
            ],
            "properties": {
              "sei": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "description": "The denom to use",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Simple contract with a QueryMsg::Price call",
            "type": "object",
            "required": [
              "simple"
            ],
            "properties": {
              "simple": {
                "type": "object",
                "required": [
                  "age_tolerance_seconds",
                  "contract"
                ],
                "properties": {
                  "age_tolerance_seconds": {
                    "description": "price age tolerance, in seconds",
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "contract": {
                    "description": "The contract to use",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SpotPriceFeedInit": {
        "description": "An individual feed used to compose a final spot price",
        "type": "object",
        "required": [
          "data",
          "inverted"
        ],
        "properties": {
          "data": {
            "description": "The data for this price feed",
            "allOf": [
              {
                "$ref": "#/definitions/SpotPriceFeedDataInit"
              }
            ]
          },
          "inverted": {
            "description": "is this price feed inverted",
            "type": "boolean"
          },
          "volatile": {
            "description": "See [SpotPriceFeed::volatile]",
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "StrideConfigInit": {
        "description": "Configuration for stride",
        "type": "object",
        "required": [
          "contract_address"
        ],
        "properties": {
          "contract_address": {
            "description": "The address of the redemption rate contract",
            "allOf": [
              {
                "$ref": "#/definitions/RawAddr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "Usd": {
        "description": "Unsigned value",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal256"
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Query messages on the market contract",
    "oneOf": [
      {
        "description": "returns [cw2::ContractVersion]",
        "type": "object",
        "required": [
          "version"
        ],
        "properties": {
          "version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Provides overall information about this market.\n\nThis is intended as catch-all for protocol wide information, both static (like market ID) and dynamic (like notional interest). The goal is to limit the total number of queries callers have to make to get relevant information.\n\n* returns [StatusResp]",
        "type": "object",
        "required": [
          "status"
        ],
        "properties": {
          "status": {
            "type": "object",
            "properties": {
              "price": {
                "description": "Price to be used as the current price",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceForQuery"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [shared::prelude::PricePoint]\n\nGets the spot price, if no time is supplied, then it's current This is the spot price as seen by the contract storage i.e. the price that was pushed via execution messages",
        "type": "object",
        "required": [
          "spot_price"
        ],
        "properties": {
          "spot_price": {
            "type": "object",
            "properties": {
              "timestamp": {
                "description": "Timestamp when the price should be effective.\n\n[None] means \"give the most recent price.\"",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [SpotPriceHistoryResp]\n\nGets a collection of historical spot prices",
        "type": "object",
        "required": [
          "spot_price_history"
        ],
        "properties": {
          "spot_price_history": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "How many prices to query",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "Order to sort by, if None then it will be descending",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "start_after": {
                "description": "Last timestamp we saw",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [OraclePriceResp]\n\nGets the current price from the oracle (for markets configured with an oracle)\n\nAlso returns prices for each feed used to compose the final price\n\nThis may be more up-to-date than the spot price which was validated and pushed into the contract storage via execution messages",
        "type": "object",
        "required": [
          "oracle_price"
        ],
        "properties": {
          "oracle_price": {
            "type": "object",
            "properties": {
              "validate_age": {
                "description": "If true then it will validate the publish_time age as though it were used to push a new spot_price update Otherwise, it just returns the oracle price as-is, even if it's old",
                "default": false,
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [super::position::PositionsResp]\n\nMaps the given PositionIds into Positions",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "required": [
              "position_ids"
            ],
            "properties": {
              "fees": {
                "description": "How do we calculate fees for this position?\n\nAny value here will override the `skip_calc_pending_fees` field.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PositionsQueryFeeApproach"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "position_ids": {
                "description": "Positions to query.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PositionId"
                }
              },
              "price": {
                "description": "Price to be used as the current price",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PriceForQuery"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "skip_calc_pending_fees": {
                "description": "Should we skip calculating pending fees?\n\nThis field is ignored if `fees` is set.\n\nThe default for this field is `false`. The behavior of this field is:\n\n* `true`: the same as [PositionsQueryFeeApproach::NoFees]\n\n* `false`: the same as [PositionsQueryFeeApproach::AllFees] (though see note on that variant, this default will likely change in the future).\n\nIt is recommended _not_ to use this field going forward, and to instead use `fees`.",
                "type": [
                  "boolean",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [LimitOrderResp]\n\nReturns the specified Limit Order",
        "type": "object",
        "required": [
          "limit_order"
        ],
        "properties": {
          "limit_order": {
            "type": "object",
            "required": [
              "order_id"
            ],
            "properties": {
              "order_id": {
                "description": "Limit order ID to query",
                "allOf": [
                  {
                    "$ref": "#/definitions/OrderId"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [LimitOrdersResp]\n\nReturns the Limit Orders for the specified addr",
        "type": "object",
        "required": [
          "limit_orders"
        ],
        "properties": {
          "limit_orders": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "description": "Number of order to return",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "Whether to return ascending or descending",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "owner": {
                "description": "Owner of limit orders",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              },
              "start_after": {
                "description": "Last limit order seen",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderId"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "returns [ClosedPositionsResp]",
        "type": "object",
        "required": [
          "closed_position_history"
        ],
        "properties": {
          "closed_position_history": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "cursor": {
                "description": "Cursor to start from, for pagination",
                "anyOf": [
                  {
                    "$ref": "#/definitions/ClosedPositionCursor"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "limit": {
                "description": "limit pagination",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "order is default Descending",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "owner": {
                "description": "Owner of the positions to get history for",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [cosmwasm_std::QueryResponse]\n\nNft proxy messages. Not meant to be called directly but rather for internal cross-contract calls\n\nhowever, these are merely queries, and can be called by anyone and clients may take advantage of this to save query gas by calling the market directly",
        "type": "object",
        "required": [
          "nft_proxy"
        ],
        "properties": {
          "nft_proxy": {
            "type": "object",
            "required": [
              "nft_msg"
            ],
            "properties": {
              "nft_msg": {
                "description": "NFT message to process",
                "allOf": [
                  {
                    "$ref": "#/definitions/QueryMsg"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [cosmwasm_std::QueryResponse]\n\nLiquidity token cw20 proxy messages. Not meant to be called directly but rather for internal cross-contract calls\n\nhowever, these are merely queries, and can be called by anyone and clients may take advantage of this to save query gas by calling the market directly",
        "type": "object",
        "required": [
          "liquidity_token_proxy"
        ],
        "properties": {
          "liquidity_token_proxy": {
            "type": "object",
            "required": [
              "kind",
              "msg"
            ],
            "properties": {
              "kind": {
                "description": "Whether to query LP or xLP tokens",
                "allOf": [
                  {
                    "$ref": "#/definitions/LiquidityTokenKind"
                  }
                ]
              },
              "msg": {
                "description": "Query to run",
                "allOf": [
                  {
                    "$ref": "#/definitions/QueryMsg"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "returns [TradeHistorySummary] for a given wallet addr",
        "type": "object",
        "required": [
          "trade_history_summary"
        ],
        "properties": {
          "trade_history_summary": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "description": "Which wallet's history are we querying?",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "returns [PositionActionHistoryResp]",
        "type": "object",
        "required": [
          "position_action_history"
        ],
        "properties": {
          "position_action_history": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "description": "Which position's history are we querying?",
                "allOf": [
                  {
                    "$ref": "#/definitions/PositionId"
                  }
                ]
              },
              "limit": {
                "description": "How many actions to query",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "Order to sort by",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "start_after": {
                "description": "Last action ID we saw",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Actions taken by a trader.\n\nSimilar to [Self::PositionActionHistory], but provides all details for an individual trader, not an individual position.\n\n* returns [TraderActionHistoryResp]",
        "type": "object",
        "required": [
          "trader_action_history"
        ],
        "properties": {
          "trader_action_history": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "description": "How many actions to query",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "Order to sort by",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "owner": {
                "description": "Which trader's history are we querying?",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              },
              "start_after": {
                "description": "Last action ID we saw",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "returns [LpActionHistoryResp]",
        "type": "object",
        "required": [
          "lp_action_history"
        ],
        "properties": {
          "lp_action_history": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "description": "Which provider's history are we querying?",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              },
              "limit": {
                "description": "How many actions to query",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "Order to sort by",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "start_after": {
                "description": "Last action ID we saw",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [LimitOrderHistoryResp]\n\nProvides information on triggered limit orders.",
        "type": "object",
        "required": [
          "limit_order_history"
        ],
        "properties": {
          "limit_order_history": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "description": "Trader's address for history we are querying",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              },
              "limit": {
                "description": "How many orders to query",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "order": {
                "description": "Order to sort the order IDs by",
                "anyOf": [
                  {
                    "$ref": "#/definitions/OrderInMessage"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "start_after": {
                "description": "Last order ID we saw",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [LpInfoResp]\n\nProvides the data needed by the earn page.",
        "type": "object",
        "required": [
          "lp_info"
        ],
        "properties": {
          "lp_info": {
            "type": "object",
            "required": [
              "liquidity_provider"
            ],
            "properties": {
              "liquidity_provider": {
                "description": "Which provider's information are we querying?",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "* returns [DeltaNeutralityFeeResp]\n\nGets the delta neutrality fee at the current price, for a given change in terms of net notional",
        "type": "object",
        "required": [
          "delta_neutrality_fee"
        ],
        "properties": {
          "delta_neutrality_fee": {
            "type": "object",
            "required": [
              "notional_delta"
            ],
            "properties": {
              "notional_delta": {
                "description": "the amount of notional that would be changed",
                "type": "string"
              },
              "pos_delta_neutrality_fee_margin": {
                "description": "for real delta neutrality fees, this is calculated internally should only be supplied if querying the fee for close or update",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Collateral"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Check if a price update would trigger a liquidation/take profit/etc.\n\n* returns [PriceWouldTriggerResp]",
        "type": "object",
        "required": [
          "price_would_trigger"
        ],
        "properties": {
          "price_would_trigger": {
            "type": "object",
            "required": [
              "price"
            ],
            "properties": {
              "price": {
                "description": "The new price of the base asset in terms of quote",
                "allOf": [
                  {
                    "$ref": "#/definitions/PriceBaseInQuote"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate deferred execution work items for the given trader.\n\nAlways begins enumeration from the most recent.\n\n* returns [ListDeferredExecsResp]",
        "type": "object",
        "required": [
          "list_deferred_execs"
        ],
        "properties": {
          "list_deferred_execs": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "description": "Trader wallet address",
                "allOf": [
                  {
                    "$ref": "#/definitions/RawAddr"
                  }
                ]
              },
              "limit": {
                "description": "How many items to request per batch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Previously seen final ID.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/DeferredExecId"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get a single deferred execution item, if available.\n\n* returns [GetDeferredExecResp]",
        "type": "object",
        "required": [
          "get_deferred_exec"
        ],
        "properties": {
          "get_deferred_exec": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "description": "ID",
                "allOf": [
                  {
                    "$ref": "#/definitions/DeferredExecId"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ClosedPositionCursor": {
        "description": "A cursor used for paginating the closed position history",
        "type": "object",
        "required": [
          "position",
          "time"
        ],
        "properties": {
          "position": {
            "description": "Last closed position ID",
            "allOf": [
              {
                "$ref": "#/definitions/PositionId"
              }
            ]
          },
          "time": {
            "description": "Last close timestamp",
            "allOf": [
              {
                "$ref": "#/definitions/Timestamp"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Collateral": {
        "description": "Unsigned value",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal256"
          }
        ]
      },
      "Decimal256": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
        "type": "string"
      },
      "DeferredExecId": {
        "description": "A unique numeric ID for each deferred execution in the protocol.",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "LiquidityTokenKind": {
        "description": "The kind of liquidity token",
        "oneOf": [
          {
            "description": "LP token",
            "type": "string",
            "enum": [
              "lp"
            ]
          },
          {
            "description": "xLP token",
            "type": "string",
            "enum": [
              "xlp"
            ]
          }
        ]
      },
      "NonZero decimal": {
        "type": "string",
        "format": "non-zero"
      },
      "OrderId": {
        "description": "A unique numeric ID for each order in the protocol.",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "OrderInMessage": {
        "description": "Like [cosmwasm_std::Order] but serialized as a string and with a schema export",
        "oneOf": [
          {
            "description": "Ascending order",
            "type": "string",
            "enum": [
              "ascending"
            ]
          },
          {
            "description": "Descending order",
            "type": "string",
            "enum": [
              "descending"
            ]
          }
        ]
      },
      "PositionId": {
        "description": "PositionId",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "PositionsQueryFeeApproach": {
        "description": "When querying an open position, how do we calculate PnL vis-a-vis fees?",
        "oneOf": [
          {
            "description": "Do not include any pending fees",
            "type": "string",
            "enum": [
              "no_fees"
            ]
          },
          {
            "description": "Include accumulated fees (borrow and funding rates), but do not include future fees (specifically DNF).",
            "type": "string",
            "enum": [
              "accumulated"
            ]
          },
          {
            "description": "Include the DNF fee in addition to accumulated fees.\n\nThis gives an idea of \"what will be my PnL if I close my position right now.\" To keep compatibility with previous contract APIs, this is the default behavior. However, going forward, `Accumulated` should be preferred, and will eventually become the default.",
            "type": "string",
            "enum": [
              "all_fees"
            ]
          }
        ]
      },
      "PriceBaseInQuote": {
        "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
        "allOf": [
          {
            "$ref": "#/definitions/NonZero decimal"
          }
        ]
      },
      "PriceCollateralInUsd": {
        "description": "PriceBaseInQuote converted to USD",
        "allOf": [
          {
            "$ref": "#/definitions/NonZero decimal"
          }
        ]
      },
      "PriceForQuery": {
        "description": "Use this price as the current price during a query.",
        "type": "object",
        "required": [
          "base",
          "collateral"
        ],
        "properties": {
          "base": {
            "description": "Price of the base asset in terms of quote",
            "allOf": [
              {
                "$ref": "#/definitions/PriceBaseInQuote"
              }
            ]
          },
          "collateral": {
            "description": "Price of the collateral asset in terms of USD\n\nThis is optional if the notional asset is USD and required otherwise.",
            "allOf": [
              {
                "$ref": "#/definitions/PriceCollateralInUsd"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "QueryMsg": {
        "description": "Query messages for a position token proxy\n\nMatches the CW721 standard.",
        "oneOf": [
          {
            "description": "* returns [OwnerOfResponse]\n\nReturn the owner of the given token, error if token does not exist",
            "type": "object",
            "required": [
              "owner_of"
            ],
            "properties": {
              "owner_of": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "description": "unset or false will filter out expired approvals, you must set to true to see them",
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [ApprovalResponse]\n\nReturn operator that can access all of the owner's tokens.",
            "type": "object",
            "required": [
              "approval"
            ],
            "properties": {
              "approval": {
                "type": "object",
                "required": [
                  "spender",
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "description": "Should we include expired approvals?",
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "spender": {
                    "description": "Spender",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [ApprovalsResponse]\n\nReturn approvals that a token has",
            "type": "object",
            "required": [
              "approvals"
            ],
            "properties": {
              "approvals": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "description": "Should we include expired approvals?",
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [OperatorsResponse]\n\nList all operators that can access all of the owner's tokens",
            "type": "object",
            "required": [
              "all_operators"
            ],
            "properties": {
              "all_operators": {
                "type": "object",
                "required": [
                  "owner"
                ],
                "properties": {
                  "include_expired": {
                    "description": "unset or false will filter out expired items, you must set to true to see them",
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "limit": {
                    "description": "How many operators to return",
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "owner": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "start_after": {
                    "description": "Last operator seen",
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [NumTokensResponse]\n\nTotal number of tokens issued",
            "type": "object",
            "required": [
              "num_tokens"
            ],
            "properties": {
              "num_tokens": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [NftContractInfo]\n\nReturns top-level metadata about the contract: `ContractInfoResponse`",
            "type": "object",
            "required": [
              "contract_info"
            ],
            "properties": {
              "contract_info": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [NftInfoResponse]\n\nReturns metadata for a given token/position the format is based on the *ERC721 Metadata JSON Schema* but directly from the contract: `NftInfoResponse`",
            "type": "object",
            "required": [
              "nft_info"
            ],
            "properties": {
              "nft_info": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [AllNftInfoResponse]\n\nReturns the result of both `NftInfo` and `OwnerOf` as one query as an optimization for clients: `AllNftInfo`",
            "type": "object",
            "required": [
              "all_nft_info"
            ],
            "properties": {
              "all_nft_info": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "description": "unset or false will filter out expired approvals, you must set to true to see them",
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "token_id": {
                    "description": "Position ID, represented as a `String` to match the NFT spec",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [TokensResponse]\n\nReturns all tokens owned by the given address, [] if unset.",
            "type": "object",
            "required": [
              "tokens"
            ],
            "properties": {
              "tokens": {
                "type": "object",
                "required": [
                  "owner"
                ],
                "properties": {
                  "limit": {
                    "description": "Number of positions to return",
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "owner": {
                    "description": "Owner to enumerate over",
                    "allOf": [
                      {
                        "$ref": "#/definitions/RawAddr"
                      }
                    ]
                  },
                  "start_after": {
                    "description": "Last position ID seen",
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "* returns [TokensResponse]\n\nRequires pagination. Lists all token_ids controlled by the contract.",
            "type": "object",
            "required": [
              "all_tokens"
            ],
            "properties": {
              "all_tokens": {
                "type": "object",
                "properties": {
                  "limit": {
                    "description": "Number of positions to return",
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "start_after": {
                    "description": "Last position ID seen",
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "returns [cw2::ContractVersion]",
            "type": "object",
            "required": [
              "version"
            ],
            "properties": {
              "version": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RawAddr": {
        "description": "A raw address passed in via JSON.\n\nThe purpose of this newtype wrapper is to make it clear at the type level if a parameter is an address, and ensure that we go through a proper validation step when using it.",
        "type": "string"
      },
      "Timestamp": {
        "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "description": "Placeholder migration message",
    "type": "object",
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "closed_position_history": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ClosedPositionsResp",
      "description": "Return value from [QueryMsg::ClosedPositionHistory]",
      "type": "object",
      "required": [
        "positions"
      ],
      "properties": {
        "cursor": {
          "description": "the next cursor to start from if we've reached the end, it's a None",
          "anyOf": [
            {
              "$ref": "#/definitions/ClosedPositionCursor"
            },
            {
              "type": "null"
            }
          ]
        },
        "positions": {
          "description": "Closed positions",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClosedPosition"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ClosedPosition": {
          "description": "Information on a closed position",
          "type": "object",
          "required": [
            "active_collateral",
            "borrow_fee_collateral",
            "borrow_fee_usd",
            "close_time",
            "crank_fee_collateral",
            "crank_fee_usd",
            "created_at",
            "delta_neutrality_fee_collateral",
            "delta_neutrality_fee_usd",
            "deposit_collateral",
            "direction_to_base",
            "entry_price_base",
            "funding_fee_collateral",
            "funding_fee_usd",
            "id",
            "liquifunded_at",
            "notional_size",
            "owner",
            "pnl_collateral",
            "pnl_usd",
            "reason",
            "settlement_time",
            "trading_fee_collateral",
            "trading_fee_usd"
          ],
          "properties": {
            "active_collateral": {
              "description": "Final active collateral, the amount sent back to the trader on close",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "borrow_fee_collateral": {
              "description": "The ongoing fee paid to LPs to lock up their deposit as counter-size collateral in this position\n\nThis value is the current balance, not a historical record of each payment",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "borrow_fee_usd": {
              "description": "Cumulative borrow fee in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "close_time": {
              "description": "the time at which the position is actually closed\n\nThis will always be the block time when the crank closed the position, whether via liquidation, deferred execution of a ClosePosition call, or liquifunding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "crank_fee_collateral": {
              "description": "Cumulative amount of crank fees paid by the position",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "crank_fee_usd": {
              "description": "Cumulative crank fees in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "created_at": {
              "description": "Timestamp the position was created, block time.",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "delta_neutrality_fee_collateral": {
              "description": "Cumulative amount of delta neutrality fees paid by (or received by) the position.\n\nPositive == outgoing, negative == incoming, like funding_fee.",
              "type": "string"
            },
            "delta_neutrality_fee_usd": {
              "description": "Cumulative delta neutrality fee in USD",
              "type": "string"
            },
            "deposit_collateral": {
              "description": "Deposit collateral for the position.\n\nThis includes any updates from collateral being added or removed.",
              "type": "string"
            },
            "deposit_collateral_usd": {
              "description": "Deposit collateral in USD, using cost basis analysis.",
              "default": "0",
              "type": "string"
            },
            "direction_to_base": {
              "description": "Direction (to base) of the position",
              "allOf": [
                {
                  "$ref": "#/definitions/DirectionToBase"
                }
              ]
            },
            "entry_price_base": {
              "description": "Entry price",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "funding_fee_collateral": {
              "description": "The ongoing fee paid (and earned!) between positions to incentivize keeping longs and shorts in balance which in turn reduces risk for LPs\n\nThis value is the current balance, not a historical record of each payment",
              "type": "string"
            },
            "funding_fee_usd": {
              "description": "Cumulative funding fee in USD",
              "type": "string"
            },
            "id": {
              "description": "ID of the position",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionId"
                }
              ]
            },
            "liquifunded_at": {
              "description": "Timestamp of the last liquifunding",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "notional_size": {
              "description": "The notional size of the position at close.",
              "type": "string"
            },
            "owner": {
              "description": "Owner at the time the position closed",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pnl_collateral": {
              "description": "Profit or loss of the position in terms of collateral.\n\nThis is the final collateral send to the trader minus all deposits (including updates).",
              "type": "string"
            },
            "pnl_usd": {
              "description": "Profit or loss, in USD\n\nThis is not simply the PnL in collateral converted to USD. It converts each individual event to a USD representation using the historical timestamp. This can be viewed as a _cost basis_ view of PnL.",
              "type": "string"
            },
            "price_point_created_at": {
              "description": "Timestamp of the price point used for creating this position.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reason": {
              "description": "the reason the position is closed",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionCloseReason"
                }
              ]
            },
            "settlement_time": {
              "description": "needed for calculating final settlement amounts if by user: same as close time if by liquidation: first time position became liquidatable",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "trading_fee_collateral": {
              "description": "The one-time fee paid when opening or updating a position\n\nthis value is the current balance, including all updates",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "trading_fee_usd": {
              "description": "Cumulative trading fees expressed in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "ClosedPositionCursor": {
          "description": "A cursor used for paginating the closed position history",
          "type": "object",
          "required": [
            "position",
            "time"
          ],
          "properties": {
            "position": {
              "description": "Last closed position ID",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionId"
                }
              ]
            },
            "time": {
              "description": "Last close timestamp",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DirectionToBase": {
          "description": "Direction in terms of base",
          "oneOf": [
            {
              "description": "Long versus base",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus base",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "LiquidationReason": {
          "description": "Reason why a position was liquidated",
          "oneOf": [
            {
              "description": "True liquidation: insufficient funds in active collateral.",
              "type": "string",
              "enum": [
                "liquidated"
              ]
            },
            {
              "description": "Maximum gains were achieved.",
              "type": "string",
              "enum": [
                "max_gains"
              ]
            },
            {
              "description": "Stop loss price override was triggered.",
              "type": "string",
              "enum": [
                "stop_loss"
              ]
            },
            {
              "description": "Specifically take profit override, not max gains.",
              "type": "string",
              "enum": [
                "take_profit"
              ]
            }
          ]
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "PositionCloseReason": {
          "description": "Reason the position was closed",
          "oneOf": [
            {
              "description": "Some kind of automated price trigger",
              "type": "object",
              "required": [
                "liquidated"
              ],
              "properties": {
                "liquidated": {
                  "$ref": "#/definitions/LiquidationReason"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "The trader directly chose to close the position",
              "type": "string",
              "enum": [
                "direct"
              ]
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "delta_neutrality_fee": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DeltaNeutralityFeeResp",
      "description": "Response for [QueryMsg::DeltaNeutralityFee]",
      "type": "object",
      "required": [
        "amount",
        "fund_total",
        "slippage_assert_price"
      ],
      "properties": {
        "amount": {
          "description": "the amount charged",
          "type": "string"
        },
        "fund_total": {
          "description": "the amount in the fund currently",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "slippage_assert_price": {
          "description": "Expected effective price after slippage, can be used for the slippage assert.",
          "allOf": [
            {
              "$ref": "#/definitions/PriceBaseInQuote"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        }
      }
    },
    "get_deferred_exec": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GetDeferredExecResp",
      "description": "Result of trying to query a single deferred execution item.",
      "oneOf": [
        {
          "description": "The requested ID was found",
          "type": "object",
          "required": [
            "found"
          ],
          "properties": {
            "found": {
              "type": "object",
              "required": [
                "item"
              ],
              "properties": {
                "item": {
                  "description": "The current state of the item",
                  "allOf": [
                    {
                      "$ref": "#/definitions/DeferredExecWithStatus"
                    }
                  ]
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "The requested ID was not found",
          "type": "object",
          "required": [
            "not_found"
          ],
          "properties": {
            "not_found": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DeferredExecCompleteTarget": {
          "description": "After successful execution of an item, what did it impact?\n\nUnlike [DeferredExecTarget] because, after execution, we always have a specific position or order impacted.",
          "oneOf": [
            {
              "description": "Modifying an existing position",
              "type": "object",
              "required": [
                "position"
              ],
              "properties": {
                "position": {
                  "$ref": "#/definitions/PositionId"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modifying an existing limit order",
              "type": "object",
              "required": [
                "order"
              ],
              "properties": {
                "order": {
                  "$ref": "#/definitions/OrderId"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "DeferredExecId": {
          "description": "A unique numeric ID for each deferred execution in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "DeferredExecItem": {
          "description": "A deferred execution work item",
          "oneOf": [
            {
              "description": "Open a new position",
              "type": "object",
              "required": [
                "open_position"
              ],
              "properties": {
                "open_position": {
                  "type": "object",
                  "required": [
                    "amount",
                    "crank_fee",
                    "crank_fee_usd",
                    "direction",
                    "leverage",
                    "max_gains"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "crank_fee": {
                      "description": "Crank fee already charged\n\nNote that this field only exists for variants where there isn't a position or order to charge the fee against. In those cases, the position/order itself is immediately updated to reflect the new charge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Collateral"
                        }
                      ]
                    },
                    "crank_fee_usd": {
                      "description": "Crank fee charged, in USD",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Usd"
                        }
                      ]
                    },
                    "direction": {
                      "description": "Direction of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DirectionToBase"
                        }
                      ]
                    },
                    "leverage": {
                      "description": "Leverage of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LeverageToBase"
                        }
                      ]
                    },
                    "max_gains": {
                      "description": "Maximum gains of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MaxGainsInQuote"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "stop_loss_override": {
                      "description": "Stop loss price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "take_profit_override": {
                      "description": "Take profit price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Add collateral to a position, causing leverage to decrease\n\nThe amount of collateral to add must be attached as funds",
              "type": "object",
              "required": [
                "update_position_add_collateral_impact_leverage"
              ],
              "properties": {
                "update_position_add_collateral_impact_leverage": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Add collateral to a position, causing notional size to increase\n\nThe amount of collateral to add must be attached as funds",
              "type": "object",
              "required": [
                "update_position_add_collateral_impact_size"
              ],
              "properties": {
                "update_position_add_collateral_impact_size": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Remove collateral from a position, causing leverage to increase",
              "type": "object",
              "required": [
                "update_position_remove_collateral_impact_leverage"
              ],
              "properties": {
                "update_position_remove_collateral_impact_leverage": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "Amount of funds to remove from the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Remove collateral from a position, causing notional size to decrease",
              "type": "object",
              "required": [
                "update_position_remove_collateral_impact_size"
              ],
              "properties": {
                "update_position_remove_collateral_impact_size": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "Amount of funds to remove from the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modify the leverage of the position\n\nThis will impact the notional size of the position",
              "type": "object",
              "required": [
                "update_position_leverage"
              ],
              "properties": {
                "update_position_leverage": {
                  "type": "object",
                  "required": [
                    "id",
                    "leverage"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "leverage": {
                      "description": "New leverage of the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LeverageToBase"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modify the max gains of a position",
              "type": "object",
              "required": [
                "update_position_max_gains"
              ],
              "properties": {
                "update_position_max_gains": {
                  "type": "object",
                  "required": [
                    "id",
                    "max_gains"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "max_gains": {
                      "description": "New max gains of the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MaxGainsInQuote"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Close a position",
              "type": "object",
              "required": [
                "close_position"
              ],
              "properties": {
                "close_position": {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to close",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Set a stop loss or take profit override. This msg will override any previous values. Passing None will remove the override.",
              "type": "object",
              "required": [
                "set_trigger_order"
              ],
              "properties": {
                "set_trigger_order": {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to modify",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "stop_loss_override": {
                      "description": "New stop loss price of the position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "take_profit_override": {
                      "description": "New take profit price of the position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Set a limit order to open a position when the price of the asset hits the specified trigger price.",
              "type": "object",
              "required": [
                "place_limit_order"
              ],
              "properties": {
                "place_limit_order": {
                  "type": "object",
                  "required": [
                    "amount",
                    "crank_fee",
                    "crank_fee_usd",
                    "direction",
                    "leverage",
                    "max_gains",
                    "trigger_price"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "crank_fee": {
                      "description": "Crank fee already charged",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Collateral"
                        }
                      ]
                    },
                    "crank_fee_usd": {
                      "description": "Crank fee charged, in USD",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Usd"
                        }
                      ]
                    },
                    "direction": {
                      "description": "Direction of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DirectionToBase"
                        }
                      ]
                    },
                    "leverage": {
                      "description": "Leverage of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LeverageToBase"
                        }
                      ]
                    },
                    "max_gains": {
                      "description": "Max gains of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MaxGainsInQuote"
                        }
                      ]
                    },
                    "stop_loss_override": {
                      "description": "Stop loss price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "take_profit_override": {
                      "description": "Take profit price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "trigger_price": {
                      "description": "Price when the order should trigger",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Cancel an open limit order",
              "type": "object",
              "required": [
                "cancel_limit_order"
              ],
              "properties": {
                "cancel_limit_order": {
                  "type": "object",
                  "required": [
                    "order_id"
                  ],
                  "properties": {
                    "order_id": {
                      "description": "ID of the order",
                      "allOf": [
                        {
                          "$ref": "#/definitions/OrderId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "DeferredExecStatus": {
          "description": "Current status of a deferred execution work item",
          "oneOf": [
            {
              "description": "Waiting to be cranked",
              "type": "string",
              "enum": [
                "pending"
              ]
            },
            {
              "description": "Successfully applied",
              "type": "object",
              "required": [
                "success"
              ],
              "properties": {
                "success": {
                  "type": "object",
                  "required": [
                    "executed",
                    "target"
                  ],
                  "properties": {
                    "executed": {
                      "description": "Timestamp when it was successfully executed",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Timestamp"
                        }
                      ]
                    },
                    "target": {
                      "description": "Entity in the system that was impacted by this execution",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DeferredExecCompleteTarget"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Did not successfully apply",
              "type": "object",
              "required": [
                "failure"
              ],
              "properties": {
                "failure": {
                  "type": "object",
                  "required": [
                    "executed",
                    "reason"
                  ],
                  "properties": {
                    "executed": {
                      "description": "Timestamp when it failed execution",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Timestamp"
                        }
                      ]
                    },
                    "reason": {
                      "description": "Reason it didn't apply successfully",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "DeferredExecWithStatus": {
          "description": "A deferred execution work item and its current status.",
          "type": "object",
          "required": [
            "created",
            "id",
            "item",
            "owner",
            "status"
          ],
          "properties": {
            "created": {
              "description": "Timestamp this was created, and therefore minimum price update timestamp needed",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "id": {
              "description": "ID of this item",
              "allOf": [
                {
                  "$ref": "#/definitions/DeferredExecId"
                }
              ]
            },
            "item": {
              "description": "Work item",
              "allOf": [
                {
                  "$ref": "#/definitions/DeferredExecItem"
                }
              ]
            },
            "owner": {
              "description": "Who owns (i.e. created) this item?",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "status": {
              "description": "Status",
              "allOf": [
                {
                  "$ref": "#/definitions/DeferredExecStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "DirectionToBase": {
          "description": "Direction in terms of base",
          "oneOf": [
            {
              "description": "Long versus base",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus base",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "OrderId": {
          "description": "A unique numeric ID for each order in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "SlippageAssert": {
          "description": "There are two sources of slippage in the protocol: - Change in the oracle price from creation of the message to execution of the message. - Change in delta neutrality fee from creation of the message to execution of the message. Slippage assert tolerance is the tolerance to the sum of the two sources of slippage.",
          "type": "object",
          "required": [
            "price",
            "tolerance"
          ],
          "properties": {
            "price": {
              "description": "Expected effective price from the sender. To incorporate tolerance on delta neutrality fee, the expected price should be modified by expected fee rate: `price = oracle_price * (1 + fee_rate)` `fee_rate` here is the ratio between the delta neutrality fee amount and notional size delta (in collateral asset).",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "tolerance": {
              "description": "Max ratio tolerance of actual trade price differing in an unfavorable direction from expected price. Tolerance of 0.01 means max 1% difference.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "limit_order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LimitOrderResp",
      "description": "Return value from [QueryMsg::LimitOrder].",
      "type": "object",
      "required": [
        "collateral",
        "direction",
        "leverage",
        "max_gains",
        "order_id",
        "trigger_price"
      ],
      "properties": {
        "collateral": {
          "description": "Amount of deposit collateral on the order",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "direction": {
          "description": "Direction of the new position",
          "allOf": [
            {
              "$ref": "#/definitions/DirectionToBase"
            }
          ]
        },
        "leverage": {
          "description": "Leverage to open the position at",
          "allOf": [
            {
              "$ref": "#/definitions/LeverageToBase"
            }
          ]
        },
        "max_gains": {
          "description": "Max gains of the new position",
          "allOf": [
            {
              "$ref": "#/definitions/MaxGainsInQuote"
            }
          ]
        },
        "order_id": {
          "description": "The order identifier",
          "allOf": [
            {
              "$ref": "#/definitions/OrderId"
            }
          ]
        },
        "stop_loss_override": {
          "description": "Stop loss of the new position",
          "anyOf": [
            {
              "$ref": "#/definitions/PriceBaseInQuote"
            },
            {
              "type": "null"
            }
          ]
        },
        "take_profit_override": {
          "description": "Take profit of the new position",
          "anyOf": [
            {
              "$ref": "#/definitions/PriceBaseInQuote"
            },
            {
              "type": "null"
            }
          ]
        },
        "trigger_price": {
          "description": "The price at which the order will trigger",
          "allOf": [
            {
              "$ref": "#/definitions/PriceBaseInQuote"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DirectionToBase": {
          "description": "Direction in terms of base",
          "oneOf": [
            {
              "description": "Long versus base",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus base",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "OrderId": {
          "description": "A unique numeric ID for each order in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "limit_order_history": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LimitOrderHistoryResp",
      "description": "Response for [QueryMsg::LimitOrderHistory]",
      "type": "object",
      "required": [
        "orders"
      ],
      "properties": {
        "next_start_after": {
          "description": "Next start_after value to continue pagination\n\nNone means no more pagination",
          "type": [
            "string",
            "null"
          ]
        },
        "orders": {
          "description": "list of triggered limit orders that happened historically",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExecutedLimitOrder"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DirectionToNotional": {
          "description": "Direction in terms of notional",
          "oneOf": [
            {
              "description": "Long versus notional",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus notional",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "ExecutedLimitOrder": {
          "description": "History information on a limit order which was triggered.",
          "type": "object",
          "required": [
            "order",
            "result",
            "timestamp"
          ],
          "properties": {
            "order": {
              "description": "The order itself",
              "allOf": [
                {
                  "$ref": "#/definitions/LimitOrder"
                }
              ]
            },
            "result": {
              "description": "The result of triggering the order",
              "allOf": [
                {
                  "$ref": "#/definitions/LimitOrderResult"
                }
              ]
            },
            "timestamp": {
              "description": "When the order was triggered",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "LimitOrder": {
          "description": "A limit order",
          "type": "object",
          "required": [
            "collateral",
            "direction",
            "leverage",
            "max_gains",
            "order_id",
            "owner",
            "trigger_price"
          ],
          "properties": {
            "collateral": {
              "description": "Deposit collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "crank_fee_collateral": {
              "description": "Crank fee charged during deferred execution and placing the limit order",
              "default": "0",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "crank_fee_usd": {
              "description": "Same as [Self::crank_fee_collateral] but cost-basis expressed in USD.",
              "default": "0",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "direction": {
              "description": "Direction of the position",
              "allOf": [
                {
                  "$ref": "#/definitions/DirectionToNotional"
                }
              ]
            },
            "leverage": {
              "description": "Leverage",
              "allOf": [
                {
                  "$ref": "#/definitions/LeverageToBase"
                }
              ]
            },
            "max_gains": {
              "description": "Maximum gains",
              "allOf": [
                {
                  "$ref": "#/definitions/MaxGainsInQuote"
                }
              ]
            },
            "order_id": {
              "description": "ID of the order",
              "allOf": [
                {
                  "$ref": "#/definitions/OrderId"
                }
              ]
            },
            "owner": {
              "description": "Owner of the order",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "stop_loss_override": {
              "description": "Stop loss price",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "take_profit_override": {
              "description": "Take profit price",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "trigger_price": {
              "description": "Price where the order will trigger",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "LimitOrderResult": {
          "description": "The result of triggering a limit order",
          "oneOf": [
            {
              "description": "Position was opened successfully",
              "type": "object",
              "required": [
                "success"
              ],
              "properties": {
                "success": {
                  "type": "object",
                  "required": [
                    "position"
                  ],
                  "properties": {
                    "position": {
                      "description": "New position ID",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Position failed to open",
              "type": "object",
              "required": [
                "failure"
              ],
              "properties": {
                "failure": {
                  "type": "object",
                  "required": [
                    "reason"
                  ],
                  "properties": {
                    "reason": {
                      "description": "Error message",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "OrderId": {
          "description": "A unique numeric ID for each order in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "limit_orders": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LimitOrdersResp",
      "description": "Response for [QueryMsg::LimitOrders]",
      "type": "object",
      "required": [
        "orders"
      ],
      "properties": {
        "next_start_after": {
          "description": "Next start_after value to continue pagination\n\nNone means no more pagination",
          "anyOf": [
            {
              "$ref": "#/definitions/OrderId"
            },
            {
              "type": "null"
            }
          ]
        },
        "orders": {
          "description": "The list of limit orders",
          "type": "array",
          "items": {
            "$ref": "#/definitions/LimitOrderResp"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DirectionToBase": {
          "description": "Direction in terms of base",
          "oneOf": [
            {
              "description": "Long versus base",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus base",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "LimitOrderResp": {
          "description": "Return value from [QueryMsg::LimitOrder].",
          "type": "object",
          "required": [
            "collateral",
            "direction",
            "leverage",
            "max_gains",
            "order_id",
            "trigger_price"
          ],
          "properties": {
            "collateral": {
              "description": "Amount of deposit collateral on the order",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "direction": {
              "description": "Direction of the new position",
              "allOf": [
                {
                  "$ref": "#/definitions/DirectionToBase"
                }
              ]
            },
            "leverage": {
              "description": "Leverage to open the position at",
              "allOf": [
                {
                  "$ref": "#/definitions/LeverageToBase"
                }
              ]
            },
            "max_gains": {
              "description": "Max gains of the new position",
              "allOf": [
                {
                  "$ref": "#/definitions/MaxGainsInQuote"
                }
              ]
            },
            "order_id": {
              "description": "The order identifier",
              "allOf": [
                {
                  "$ref": "#/definitions/OrderId"
                }
              ]
            },
            "stop_loss_override": {
              "description": "Stop loss of the new position",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "take_profit_override": {
              "description": "Take profit of the new position",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "trigger_price": {
              "description": "The price at which the order will trigger",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "OrderId": {
          "description": "A unique numeric ID for each order in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "liquidity_token_proxy": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Binary",
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "list_deferred_execs": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ListDeferredExecsResp",
      "description": "Enumeration API for getting deferred exec IDs",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "items": {
          "description": "Next batch of items",
          "type": "array",
          "items": {
            "$ref": "#/definitions/DeferredExecWithStatus"
          }
        },
        "next_start_after": {
          "description": "Only `Some` if more IDs exist",
          "anyOf": [
            {
              "$ref": "#/definitions/DeferredExecId"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DeferredExecCompleteTarget": {
          "description": "After successful execution of an item, what did it impact?\n\nUnlike [DeferredExecTarget] because, after execution, we always have a specific position or order impacted.",
          "oneOf": [
            {
              "description": "Modifying an existing position",
              "type": "object",
              "required": [
                "position"
              ],
              "properties": {
                "position": {
                  "$ref": "#/definitions/PositionId"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modifying an existing limit order",
              "type": "object",
              "required": [
                "order"
              ],
              "properties": {
                "order": {
                  "$ref": "#/definitions/OrderId"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "DeferredExecId": {
          "description": "A unique numeric ID for each deferred execution in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "DeferredExecItem": {
          "description": "A deferred execution work item",
          "oneOf": [
            {
              "description": "Open a new position",
              "type": "object",
              "required": [
                "open_position"
              ],
              "properties": {
                "open_position": {
                  "type": "object",
                  "required": [
                    "amount",
                    "crank_fee",
                    "crank_fee_usd",
                    "direction",
                    "leverage",
                    "max_gains"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "crank_fee": {
                      "description": "Crank fee already charged\n\nNote that this field only exists for variants where there isn't a position or order to charge the fee against. In those cases, the position/order itself is immediately updated to reflect the new charge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Collateral"
                        }
                      ]
                    },
                    "crank_fee_usd": {
                      "description": "Crank fee charged, in USD",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Usd"
                        }
                      ]
                    },
                    "direction": {
                      "description": "Direction of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DirectionToBase"
                        }
                      ]
                    },
                    "leverage": {
                      "description": "Leverage of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LeverageToBase"
                        }
                      ]
                    },
                    "max_gains": {
                      "description": "Maximum gains of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MaxGainsInQuote"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "stop_loss_override": {
                      "description": "Stop loss price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "take_profit_override": {
                      "description": "Take profit price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Add collateral to a position, causing leverage to decrease\n\nThe amount of collateral to add must be attached as funds",
              "type": "object",
              "required": [
                "update_position_add_collateral_impact_leverage"
              ],
              "properties": {
                "update_position_add_collateral_impact_leverage": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Add collateral to a position, causing notional size to increase\n\nThe amount of collateral to add must be attached as funds",
              "type": "object",
              "required": [
                "update_position_add_collateral_impact_size"
              ],
              "properties": {
                "update_position_add_collateral_impact_size": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Remove collateral from a position, causing leverage to increase",
              "type": "object",
              "required": [
                "update_position_remove_collateral_impact_leverage"
              ],
              "properties": {
                "update_position_remove_collateral_impact_leverage": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "Amount of funds to remove from the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Remove collateral from a position, causing notional size to decrease",
              "type": "object",
              "required": [
                "update_position_remove_collateral_impact_size"
              ],
              "properties": {
                "update_position_remove_collateral_impact_size": {
                  "type": "object",
                  "required": [
                    "amount",
                    "id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "Amount of funds to remove from the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modify the leverage of the position\n\nThis will impact the notional size of the position",
              "type": "object",
              "required": [
                "update_position_leverage"
              ],
              "properties": {
                "update_position_leverage": {
                  "type": "object",
                  "required": [
                    "id",
                    "leverage"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "leverage": {
                      "description": "New leverage of the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LeverageToBase"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modify the max gains of a position",
              "type": "object",
              "required": [
                "update_position_max_gains"
              ],
              "properties": {
                "update_position_max_gains": {
                  "type": "object",
                  "required": [
                    "id",
                    "max_gains"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to update",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "max_gains": {
                      "description": "New max gains of the position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MaxGainsInQuote"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Close a position",
              "type": "object",
              "required": [
                "close_position"
              ],
              "properties": {
                "close_position": {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to close",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "slippage_assert": {
                      "description": "Assertion that the price has not moved too far",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/SlippageAssert"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Set a stop loss or take profit override. This msg will override any previous values. Passing None will remove the override.",
              "type": "object",
              "required": [
                "set_trigger_order"
              ],
              "properties": {
                "set_trigger_order": {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "description": "ID of position to modify",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    },
                    "stop_loss_override": {
                      "description": "New stop loss price of the position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "take_profit_override": {
                      "description": "New take profit price of the position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Set a limit order to open a position when the price of the asset hits the specified trigger price.",
              "type": "object",
              "required": [
                "place_limit_order"
              ],
              "properties": {
                "place_limit_order": {
                  "type": "object",
                  "required": [
                    "amount",
                    "crank_fee",
                    "crank_fee_usd",
                    "direction",
                    "leverage",
                    "max_gains",
                    "trigger_price"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of collateral provided",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    },
                    "crank_fee": {
                      "description": "Crank fee already charged",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Collateral"
                        }
                      ]
                    },
                    "crank_fee_usd": {
                      "description": "Crank fee charged, in USD",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Usd"
                        }
                      ]
                    },
                    "direction": {
                      "description": "Direction of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DirectionToBase"
                        }
                      ]
                    },
                    "leverage": {
                      "description": "Leverage of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LeverageToBase"
                        }
                      ]
                    },
                    "max_gains": {
                      "description": "Max gains of new position",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MaxGainsInQuote"
                        }
                      ]
                    },
                    "stop_loss_override": {
                      "description": "Stop loss price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "take_profit_override": {
                      "description": "Take profit price of new position",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "trigger_price": {
                      "description": "Price when the order should trigger",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PriceBaseInQuote"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Cancel an open limit order",
              "type": "object",
              "required": [
                "cancel_limit_order"
              ],
              "properties": {
                "cancel_limit_order": {
                  "type": "object",
                  "required": [
                    "order_id"
                  ],
                  "properties": {
                    "order_id": {
                      "description": "ID of the order",
                      "allOf": [
                        {
                          "$ref": "#/definitions/OrderId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "DeferredExecStatus": {
          "description": "Current status of a deferred execution work item",
          "oneOf": [
            {
              "description": "Waiting to be cranked",
              "type": "string",
              "enum": [
                "pending"
              ]
            },
            {
              "description": "Successfully applied",
              "type": "object",
              "required": [
                "success"
              ],
              "properties": {
                "success": {
                  "type": "object",
                  "required": [
                    "executed",
                    "target"
                  ],
                  "properties": {
                    "executed": {
                      "description": "Timestamp when it was successfully executed",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Timestamp"
                        }
                      ]
                    },
                    "target": {
                      "description": "Entity in the system that was impacted by this execution",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DeferredExecCompleteTarget"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Did not successfully apply",
              "type": "object",
              "required": [
                "failure"
              ],
              "properties": {
                "failure": {
                  "type": "object",
                  "required": [
                    "executed",
                    "reason"
                  ],
                  "properties": {
                    "executed": {
                      "description": "Timestamp when it failed execution",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Timestamp"
                        }
                      ]
                    },
                    "reason": {
                      "description": "Reason it didn't apply successfully",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "DeferredExecWithStatus": {
          "description": "A deferred execution work item and its current status.",
          "type": "object",
          "required": [
            "created",
            "id",
            "item",
            "owner",
            "status"
          ],
          "properties": {
            "created": {
              "description": "Timestamp this was created, and therefore minimum price update timestamp needed",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "id": {
              "description": "ID of this item",
              "allOf": [
                {
                  "$ref": "#/definitions/DeferredExecId"
                }
              ]
            },
            "item": {
              "description": "Work item",
              "allOf": [
                {
                  "$ref": "#/definitions/DeferredExecItem"
                }
              ]
            },
            "owner": {
              "description": "Who owns (i.e. created) this item?",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "status": {
              "description": "Status",
              "allOf": [
                {
                  "$ref": "#/definitions/DeferredExecStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "DirectionToBase": {
          "description": "Direction in terms of base",
          "oneOf": [
            {
              "description": "Long versus base",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus base",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "OrderId": {
          "description": "A unique numeric ID for each order in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "SlippageAssert": {
          "description": "There are two sources of slippage in the protocol: - Change in the oracle price from creation of the message to execution of the message. - Change in delta neutrality fee from creation of the message to execution of the message. Slippage assert tolerance is the tolerance to the sum of the two sources of slippage.",
          "type": "object",
          "required": [
            "price",
            "tolerance"
          ],
          "properties": {
            "price": {
              "description": "Expected effective price from the sender. To incorporate tolerance on delta neutrality fee, the expected price should be modified by expected fee rate: `price = oracle_price * (1 + fee_rate)` `fee_rate` here is the ratio between the delta neutrality fee amount and notional size delta (in collateral asset).",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "tolerance": {
              "description": "Max ratio tolerance of actual trade price differing in an unfavorable direction from expected price. Tolerance of 0.01 means max 1% difference.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "lp_action_history": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LpActionHistoryResp",
      "description": "Response for [QueryMsg::LpActionHistory]",
      "type": "object",
      "required": [
        "actions"
      ],
      "properties": {
        "actions": {
          "description": "list of earn actions that happened historically",
          "type": "array",
          "items": {
            "$ref": "#/definitions/LpAction"
          }
        },
        "next_start_after": {
          "description": "Next start_after value to continue pagination\n\nNone means no more pagination",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "LpAction": {
          "description": "A distinct lp history action",
          "type": "object",
          "required": [
            "collateral",
            "collateral_usd",
            "kind",
            "timestamp"
          ],
          "properties": {
            "collateral": {
              "description": "Amount of collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "collateral_usd": {
              "description": "Value of that collateral in USD at the time",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "kind": {
              "description": "Kind of action",
              "allOf": [
                {
                  "$ref": "#/definitions/LpActionKind"
                }
              ]
            },
            "timestamp": {
              "description": "When the action happened",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "tokens": {
              "description": "How many tokens were involved, if relevant",
              "anyOf": [
                {
                  "$ref": "#/definitions/LpToken"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "LpActionKind": {
          "description": "Kind of action for a [LpAction].",
          "oneOf": [
            {
              "description": "via [ExecuteMsg::DepositLiquidity]",
              "type": "string",
              "enum": [
                "deposit_lp"
              ]
            },
            {
              "description": "via [ExecuteMsg::DepositLiquidity]",
              "type": "string",
              "enum": [
                "deposit_xlp"
              ]
            },
            {
              "description": "via [ExecuteMsg::ReinvestYield]",
              "type": "string",
              "enum": [
                "reinvest_yield_lp"
              ]
            },
            {
              "description": "via [ExecuteMsg::ReinvestYield]",
              "type": "string",
              "enum": [
                "reinvest_yield_xlp"
              ]
            },
            {
              "description": "via [ExecuteMsg::UnstakeXlp] the amount of collateral is determined by the time they send their message [ExecuteMsg::CollectUnstakedLp] is *not* accounted for here",
              "type": "string",
              "enum": [
                "unstake_xlp"
              ]
            },
            {
              "description": "Some amount of unstaked LP has been collected into actual LP.",
              "type": "string",
              "enum": [
                "collect_lp"
              ]
            },
            {
              "description": "via [ExecuteMsg::WithdrawLiquidity]",
              "type": "string",
              "enum": [
                "withdraw"
              ]
            },
            {
              "description": "via [ExecuteMsg::ClaimYield]",
              "type": "string",
              "enum": [
                "claim_yield"
              ]
            }
          ]
        },
        "LpToken": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "lp_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LpInfoResp",
      "description": "Returned by [QueryMsg::LpInfo]",
      "type": "object",
      "required": [
        "available_crank_rewards",
        "available_yield",
        "available_yield_lp",
        "available_yield_xlp",
        "history",
        "lp_amount",
        "lp_collateral",
        "xlp_amount",
        "xlp_collateral"
      ],
      "properties": {
        "available_crank_rewards": {
          "description": "Available crank rewards",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "available_yield": {
          "description": "Total available yield, sum of the available LP, xLP, and crank rewards.",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "available_yield_lp": {
          "description": "Available yield from LP tokens",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "available_yield_xlp": {
          "description": "Available yield from xLP tokens",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "history": {
          "description": "Historical information on LP activity",
          "allOf": [
            {
              "$ref": "#/definitions/LpHistorySummary"
            }
          ]
        },
        "liquidity_cooldown": {
          "description": "Liquidity cooldown information, if active.",
          "anyOf": [
            {
              "$ref": "#/definitions/LiquidityCooldown"
            },
            {
              "type": "null"
            }
          ]
        },
        "lp_amount": {
          "description": "This LP amount includes both actual LP tokens and xLP unstaked to LP but not yet collected.",
          "allOf": [
            {
              "$ref": "#/definitions/LpToken"
            }
          ]
        },
        "lp_collateral": {
          "description": "Collateral backing the LP tokens",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "unstaking": {
          "description": "Current status of an unstaking, if under way\n\nThis will return `Some` from the time the provider begins an unstaking process until either:\n\n1. They either cancel it, _or_ 2. They unstake all request xLP into LP _and_ collect that LP within the contract.",
          "anyOf": [
            {
              "$ref": "#/definitions/UnstakingStatus"
            },
            {
              "type": "null"
            }
          ]
        },
        "xlp_amount": {
          "description": "This shows the balance of xLP minus any xLP already unstaked.",
          "allOf": [
            {
              "$ref": "#/definitions/LpToken"
            }
          ]
        },
        "xlp_collateral": {
          "description": "Collateral backing the xLP tokens",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "LiquidityCooldown": {
          "description": "When a liquidity cooldown period will end",
          "type": "object",
          "required": [
            "at",
            "seconds"
          ],
          "properties": {
            "at": {
              "description": "Timestamp when it will end",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "seconds": {
              "description": "Number of seconds until it will end",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "LpHistorySummary": {
          "description": "The summary for LP history",
          "type": "object",
          "required": [
            "deposit",
            "deposit_usd",
            "yield",
            "yield_usd"
          ],
          "properties": {
            "deposit": {
              "description": "How much collateral was deposited in total",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "deposit_usd": {
              "description": "Value of the collateral in USD at time of deposit",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "yield": {
              "description": "Cumulative yield claimed by the provider",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "yield_usd": {
              "description": "Cumulative yield expressed in USD at time of claiming",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "LpToken": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "UnstakingStatus": {
          "description": "Status of an ongoing unstaking process.",
          "type": "object",
          "required": [
            "available",
            "collected",
            "end",
            "pending",
            "start",
            "xlp_unstaking",
            "xlp_unstaking_collateral"
          ],
          "properties": {
            "available": {
              "description": "Total amount of LP tokens that have been unstaked and not yet collected",
              "allOf": [
                {
                  "$ref": "#/definitions/LpToken"
                }
              ]
            },
            "collected": {
              "description": "Total amount of LP tokens that have been unstaked and collected",
              "allOf": [
                {
                  "$ref": "#/definitions/LpToken"
                }
              ]
            },
            "end": {
              "description": "This will be in the future if unstaking is incomplete",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "pending": {
              "description": "Total amount of xLP tokens that are still pending unstaking",
              "allOf": [
                {
                  "$ref": "#/definitions/LpToken"
                }
              ]
            },
            "start": {
              "description": "When the unstaking began",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "xlp_unstaking": {
              "description": "Total amount requested to be unstaked\n\nNote that this value must be the sum of collected, available, and pending.",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "xlp_unstaking_collateral": {
              "description": "Collateral, at current exchange rate, underlying the [UnstakingStatus::xlp_unstaking]",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "nft_proxy": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Binary",
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "oracle_price": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OraclePriceResp",
      "description": "Response for [QueryMsg::OraclePrice]",
      "type": "object",
      "required": [
        "composed_price",
        "pyth",
        "sei",
        "stride"
      ],
      "properties": {
        "composed_price": {
          "description": "The final, composed price. See [QueryMsg::OraclePrice] for more information about this value",
          "allOf": [
            {
              "$ref": "#/definitions/PricePoint"
            }
          ]
        },
        "pyth": {
          "description": "A map of each pyth id used in this market to the price and publish time",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/OraclePriceFeedPythResp"
          }
        },
        "sei": {
          "description": "A map of each sei denom used in this market to the price",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/OraclePriceFeedSeiResp"
          }
        },
        "simple": {
          "description": "A map of each simple contract used in this market to the contract price",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/OraclePriceFeedSimpleResp"
          }
        },
        "stride": {
          "description": "A map of each stride denom used in this market to the redemption price",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/OraclePriceFeedStrideResp"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "BlockInfo": {
          "type": "object",
          "required": [
            "chain_id",
            "height",
            "time"
          ],
          "properties": {
            "chain_id": {
              "type": "string"
            },
            "height": {
              "description": "The height of a block is the number of blocks preceding it in the blockchain.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "time": {
              "description": "Absolute time of the block creation in seconds since the UNIX epoch (00:00:00 on 1970-01-01 UTC).\n\nThe source of this is the [BFT Time in Tendermint](https://github.com/tendermint/tendermint/blob/58dc1726/spec/consensus/bft-time.md), which has the same nanosecond precision as the `Timestamp` type.\n\n# Examples\n\nUsing chrono:\n\n``` # use cosmwasm_std::{Addr, BlockInfo, ContractInfo, Env, MessageInfo, Timestamp, TransactionInfo}; # let env = Env { #     block: BlockInfo { #         height: 12_345, #         time: Timestamp::from_nanos(1_571_797_419_879_305_533), #         chain_id: \"cosmos-testnet-14002\".to_string(), #     }, #     transaction: Some(TransactionInfo { index: 3 }), #     contract: ContractInfo { #         address: Addr::unchecked(\"contract\"), #     }, # }; # extern crate chrono; use chrono::NaiveDateTime; let seconds = env.block.time.seconds(); let nsecs = env.block.time.subsec_nanos(); let dt = NaiveDateTime::from_timestamp(seconds as i64, nsecs as u32); ```\n\nCreating a simple millisecond-precision timestamp (as used in JavaScript):\n\n``` # use cosmwasm_std::{Addr, BlockInfo, ContractInfo, Env, MessageInfo, Timestamp, TransactionInfo}; # let env = Env { #     block: BlockInfo { #         height: 12_345, #         time: Timestamp::from_nanos(1_571_797_419_879_305_533), #         chain_id: \"cosmos-testnet-14002\".to_string(), #     }, #     transaction: Some(TransactionInfo { index: 3 }), #     contract: ContractInfo { #         address: Addr::unchecked(\"contract\"), #     }, # }; let millis = env.block.time.nanos() / 1_000_000; ```",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            }
          }
        },
        "MarketType": {
          "description": "Whether the collateral asset is the same as the quote or base asset.",
          "oneOf": [
            {
              "description": "A market where the collateral is the quote asset",
              "type": "string",
              "enum": [
                "collateral_is_quote"
              ]
            },
            {
              "description": "A market where the collateral is the base asset",
              "type": "string",
              "enum": [
                "collateral_is_base"
              ]
            }
          ]
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "OraclePriceFeedPythResp": {
          "description": "Part of [OraclePriceResp]",
          "type": "object",
          "required": [
            "price",
            "publish_time",
            "volatile"
          ],
          "properties": {
            "price": {
              "description": "The pyth price",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "publish_time": {
              "description": "The pyth publish time",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "volatile": {
              "description": "Is this considered a volatile feed?",
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "OraclePriceFeedSeiResp": {
          "description": "Part of [OraclePriceResp]",
          "type": "object",
          "required": [
            "price",
            "publish_time",
            "volatile"
          ],
          "properties": {
            "price": {
              "description": "The Sei price",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "publish_time": {
              "description": "The Sei publish time",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "volatile": {
              "description": "Is this considered a volatile feed?",
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "OraclePriceFeedSimpleResp": {
          "description": "Part of [OraclePriceResp]",
          "type": "object",
          "required": [
            "block_info",
            "value"
          ],
          "properties": {
            "block_info": {
              "description": "The block info when this price was set",
              "allOf": [
                {
                  "$ref": "#/definitions/BlockInfo"
                }
              ]
            },
            "timestamp": {
              "description": "Optional timestamp for the price, independent of block_info.time",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "value": {
              "description": "The price value",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "volatile": {
              "description": "Is this considered a volatile feed?",
              "default": false,
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "OraclePriceFeedStrideResp": {
          "description": "Part of [OraclePriceResp]",
          "type": "object",
          "required": [
            "publish_time",
            "redemption_rate",
            "volatile"
          ],
          "properties": {
            "publish_time": {
              "description": "The redemption price publish time",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "redemption_rate": {
              "description": "The redemption rate",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "volatile": {
              "description": "Is this considered a volatile feed?",
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "Price": {
          "description": "The price of the pair as used internally by the protocol, given as `collateral / notional`.",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PriceCollateralInUsd": {
          "description": "PriceBaseInQuote converted to USD",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PricePoint": {
          "description": "All prices in the protocol for a given point in time.\n\nThis includes extra information necessary for performing all conversions, such as the [MarketType].",
          "type": "object",
          "required": [
            "is_notional_usd",
            "market_type",
            "price_base",
            "price_notional",
            "price_usd",
            "timestamp"
          ],
          "properties": {
            "is_notional_usd": {
              "description": "Is the notional asset USD?\n\nUsed for avoiding lossy conversions to USD when they aren't needed.\n\nWe do not need to track if the collateral asset is USD, since USD can never be used as collateral directly. Instead, stablecoins would be used, in which case an explicit price to USD is always needed.",
              "type": "boolean"
            },
            "market_type": {
              "description": "Indicates if this market uses collateral as base or quote, needed for price conversions.",
              "allOf": [
                {
                  "$ref": "#/definitions/MarketType"
                }
              ]
            },
            "price_base": {
              "description": "Price of the base asset in terms of the quote.",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "price_notional": {
              "description": "Price as used internally by the protocol, in terms of collateral and notional.\n\nThis is generally less useful for external consumers, where [PricePoint::price_usd] and [PricePoint::price_base] are used.",
              "allOf": [
                {
                  "$ref": "#/definitions/Price"
                }
              ]
            },
            "price_usd": {
              "description": "Price of the collateral asset in terms of USD.\n\nThis is generally used for reporting of values like PnL and trade volume.",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceCollateralInUsd"
                }
              ]
            },
            "publish_time": {
              "description": "Latest price publish time for the feeds composing the price, if available\n\nThis field will always be empty since implementation of deferred execution.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "publish_time_usd": {
              "description": "Latest price publish time for the feeds composing the price_usd, if available\n\nThis field will always be empty since implementation of deferred execution.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "description": "Publish time of this price point.\n\nBefore deferred execution, this was the block time when the field was added. Since deferred execution, this is a calculated value based on the publish times of individual feeds.",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        }
      }
    },
    "position_action_history": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionActionHistoryResp",
      "description": "Response for [QueryMsg::PositionActionHistory]",
      "type": "object",
      "required": [
        "actions"
      ],
      "properties": {
        "actions": {
          "description": "list of position actions that happened historically",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PositionAction"
          }
        },
        "next_start_after": {
          "description": "Next start_after value to continue pagination\n\nNone means no more pagination",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "PositionAction": {
          "description": "A distinct position history action",
          "type": "object",
          "required": [
            "collateral",
            "kind",
            "timestamp"
          ],
          "properties": {
            "collateral": {
              "description": "the amount of collateral at the time of the action",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "delta_neutrality_fee": {
              "description": "The delta neutrality fee paid (or, if negative, received) in USD",
              "type": [
                "string",
                "null"
              ]
            },
            "id": {
              "description": "ID of the position impacted\n\nFor ease of migration, we allow for a missing position ID.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PositionId"
                },
                {
                  "type": "null"
                }
              ]
            },
            "kind": {
              "description": "Kind of action taken by the trader",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionActionKind"
                }
              ]
            },
            "leverage": {
              "description": "Leverage of the position at the time of the action, if relevant",
              "anyOf": [
                {
                  "$ref": "#/definitions/LeverageToBase"
                },
                {
                  "type": "null"
                }
              ]
            },
            "max_gains": {
              "description": "max gains in quote",
              "anyOf": [
                {
                  "$ref": "#/definitions/MaxGainsInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "new_owner": {
              "description": "If this is a position transfer, the new owner.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "old_owner": {
              "description": "If this is a position transfer, the previous owner.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stop_loss_override": {
              "description": "The stop loss override, if set.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "take_profit_override": {
              "description": "The take profit override, if set.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "description": "Timestamp when the action occurred",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "trade_fee": {
              "description": "the trade fee in USD",
              "anyOf": [
                {
                  "$ref": "#/definitions/Usd"
                },
                {
                  "type": "null"
                }
              ]
            },
            "transfer_collateral": {
              "description": "The amount of collateral transferred to or from the trader",
              "default": "0",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "PositionActionKind": {
          "description": "Action taken by trader for a [PositionAction]",
          "oneOf": [
            {
              "description": "Open a new position",
              "type": "string",
              "enum": [
                "open"
              ]
            },
            {
              "description": "Updated an existing position",
              "type": "string",
              "enum": [
                "update"
              ]
            },
            {
              "description": "Close a position",
              "type": "string",
              "enum": [
                "close"
              ]
            },
            {
              "description": "Position was transferred between wallets",
              "type": "string",
              "enum": [
                "transfer"
              ]
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsResp",
      "description": "Response from [QueryMsg::Positions]",
      "type": "object",
      "required": [
        "closed",
        "pending_close",
        "positions"
      ],
      "properties": {
        "closed": {
          "description": "Positions which have already been closed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClosedPosition"
          }
        },
        "pending_close": {
          "description": "Positions which are pending a liquidation/take profit\n\nThe closed position information is not the final version of the data, the close process itself still needs to make final payments.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClosedPosition"
          }
        },
        "positions": {
          "description": "Open positions",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PositionQueryResponse"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ClosedPosition": {
          "description": "Information on a closed position",
          "type": "object",
          "required": [
            "active_collateral",
            "borrow_fee_collateral",
            "borrow_fee_usd",
            "close_time",
            "crank_fee_collateral",
            "crank_fee_usd",
            "created_at",
            "delta_neutrality_fee_collateral",
            "delta_neutrality_fee_usd",
            "deposit_collateral",
            "direction_to_base",
            "entry_price_base",
            "funding_fee_collateral",
            "funding_fee_usd",
            "id",
            "liquifunded_at",
            "notional_size",
            "owner",
            "pnl_collateral",
            "pnl_usd",
            "reason",
            "settlement_time",
            "trading_fee_collateral",
            "trading_fee_usd"
          ],
          "properties": {
            "active_collateral": {
              "description": "Final active collateral, the amount sent back to the trader on close",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "borrow_fee_collateral": {
              "description": "The ongoing fee paid to LPs to lock up their deposit as counter-size collateral in this position\n\nThis value is the current balance, not a historical record of each payment",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "borrow_fee_usd": {
              "description": "Cumulative borrow fee in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "close_time": {
              "description": "the time at which the position is actually closed\n\nThis will always be the block time when the crank closed the position, whether via liquidation, deferred execution of a ClosePosition call, or liquifunding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "crank_fee_collateral": {
              "description": "Cumulative amount of crank fees paid by the position",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "crank_fee_usd": {
              "description": "Cumulative crank fees in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "created_at": {
              "description": "Timestamp the position was created, block time.",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "delta_neutrality_fee_collateral": {
              "description": "Cumulative amount of delta neutrality fees paid by (or received by) the position.\n\nPositive == outgoing, negative == incoming, like funding_fee.",
              "type": "string"
            },
            "delta_neutrality_fee_usd": {
              "description": "Cumulative delta neutrality fee in USD",
              "type": "string"
            },
            "deposit_collateral": {
              "description": "Deposit collateral for the position.\n\nThis includes any updates from collateral being added or removed.",
              "type": "string"
            },
            "deposit_collateral_usd": {
              "description": "Deposit collateral in USD, using cost basis analysis.",
              "default": "0",
              "type": "string"
            },
            "direction_to_base": {
              "description": "Direction (to base) of the position",
              "allOf": [
                {
                  "$ref": "#/definitions/DirectionToBase"
                }
              ]
            },
            "entry_price_base": {
              "description": "Entry price",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "funding_fee_collateral": {
              "description": "The ongoing fee paid (and earned!) between positions to incentivize keeping longs and shorts in balance which in turn reduces risk for LPs\n\nThis value is the current balance, not a historical record of each payment",
              "type": "string"
            },
            "funding_fee_usd": {
              "description": "Cumulative funding fee in USD",
              "type": "string"
            },
            "id": {
              "description": "ID of the position",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionId"
                }
              ]
            },
            "liquifunded_at": {
              "description": "Timestamp of the last liquifunding",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "notional_size": {
              "description": "The notional size of the position at close.",
              "type": "string"
            },
            "owner": {
              "description": "Owner at the time the position closed",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pnl_collateral": {
              "description": "Profit or loss of the position in terms of collateral.\n\nThis is the final collateral send to the trader minus all deposits (including updates).",
              "type": "string"
            },
            "pnl_usd": {
              "description": "Profit or loss, in USD\n\nThis is not simply the PnL in collateral converted to USD. It converts each individual event to a USD representation using the historical timestamp. This can be viewed as a _cost basis_ view of PnL.",
              "type": "string"
            },
            "price_point_created_at": {
              "description": "Timestamp of the price point used for creating this position.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reason": {
              "description": "the reason the position is closed",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionCloseReason"
                }
              ]
            },
            "settlement_time": {
              "description": "needed for calculating final settlement amounts if by user: same as close time if by liquidation: first time position became liquidatable",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "trading_fee_collateral": {
              "description": "The one-time fee paid when opening or updating a position\n\nthis value is the current balance, including all updates",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "trading_fee_usd": {
              "description": "Cumulative trading fees expressed in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DirectionToBase": {
          "description": "Direction in terms of base",
          "oneOf": [
            {
              "description": "Long versus base",
              "type": "string",
              "enum": [
                "long"
              ]
            },
            {
              "description": "Short versus base",
              "type": "string",
              "enum": [
                "short"
              ]
            }
          ]
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "LiquidationMargin": {
          "description": "Liquidation margin for a position, broken down by component.\n\nEach field represents how much collateral has been set aside for the given fees, or the maximum amount the position can pay at liquifunding.",
          "type": "object",
          "required": [
            "borrow",
            "crank",
            "delta_neutrality",
            "funding"
          ],
          "properties": {
            "borrow": {
              "description": "Maximum borrow fee payment.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "crank": {
              "description": "Funds set aside for a single crank fee.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "delta_neutrality": {
              "description": "Maximum delta neutrality fee.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "exposure": {
              "description": "Funds set aside to cover additional price exposure losses from sparse price updates.",
              "default": "0",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "funding": {
              "description": "Maximum funding payment.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "LiquidationReason": {
          "description": "Reason why a position was liquidated",
          "oneOf": [
            {
              "description": "True liquidation: insufficient funds in active collateral.",
              "type": "string",
              "enum": [
                "liquidated"
              ]
            },
            {
              "description": "Maximum gains were achieved.",
              "type": "string",
              "enum": [
                "max_gains"
              ]
            },
            {
              "description": "Stop loss price override was triggered.",
              "type": "string",
              "enum": [
                "stop_loss"
              ]
            },
            {
              "description": "Specifically take profit override, not max gains.",
              "type": "string",
              "enum": [
                "take_profit"
              ]
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "PositionCloseReason": {
          "description": "Reason the position was closed",
          "oneOf": [
            {
              "description": "Some kind of automated price trigger",
              "type": "object",
              "required": [
                "liquidated"
              ],
              "properties": {
                "liquidated": {
                  "$ref": "#/definitions/LiquidationReason"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "The trader directly chose to close the position",
              "type": "string",
              "enum": [
                "direct"
              ]
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PositionQueryResponse": {
          "description": "Query response representing current state of a position",
          "type": "object",
          "required": [
            "active_collateral",
            "active_collateral_usd",
            "borrow_fee_collateral",
            "borrow_fee_usd",
            "counter_collateral",
            "counter_leverage",
            "crank_fee_collateral",
            "crank_fee_usd",
            "created_at",
            "delta_neutrality_fee_collateral",
            "delta_neutrality_fee_usd",
            "deposit_collateral",
            "deposit_collateral_usd",
            "direction_to_base",
            "dnf_on_close_collateral",
            "entry_price_base",
            "funding_fee_collateral",
            "funding_fee_usd",
            "id",
            "leverage",
            "liquidation_margin",
            "liquifunded_at",
            "max_gains_in_quote",
            "next_liquifunding",
            "notional_size",
            "notional_size_in_collateral",
            "owner",
            "pnl_collateral",
            "pnl_usd",
            "position_size_base",
            "position_size_usd",
            "trading_fee_collateral",
            "trading_fee_usd"
          ],
          "properties": {
            "active_collateral": {
              "description": "See [Position::active_collateral]",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "active_collateral_usd": {
              "description": "[Self::active_collateral] converted to USD at the current exchange rate",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "borrow_fee_collateral": {
              "description": "The ongoing fee paid to LPs to lock up their deposit as counter-size collateral in this position\n\nThis value is the current balance, not a historical record of each payment",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "borrow_fee_usd": {
              "description": "USD expression of [Self::borrow_fee_collateral] using cost-basis calculation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "counter_collateral": {
              "description": "See [Position::counter_collateral]",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "counter_leverage": {
              "description": "Leverage of the counter collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/LeverageToBase"
                }
              ]
            },
            "crank_fee_collateral": {
              "description": "Cumulative amount of crank fees paid by the position",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "crank_fee_usd": {
              "description": "USD expression of [Self::crank_fee_collateral] using cost-basis calculation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "created_at": {
              "description": "When the position was opened, block time",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "delta_neutrality_fee_collateral": {
              "description": "Aggregate delta neutrality fees paid or received through position opens and upates.",
              "type": "string"
            },
            "delta_neutrality_fee_usd": {
              "description": "USD expression of [Self::delta_neutrality_fee_collateral] using cost-basis calculation.",
              "type": "string"
            },
            "deposit_collateral": {
              "description": "See [Position::deposit_collateral]",
              "type": "string"
            },
            "deposit_collateral_usd": {
              "description": "USD expression of [Self::deposit_collateral] using cost-basis calculation.",
              "type": "string"
            },
            "direction_to_base": {
              "description": "Direction",
              "allOf": [
                {
                  "$ref": "#/definitions/DirectionToBase"
                }
              ]
            },
            "dnf_on_close_collateral": {
              "description": "DNF that would be charged (positive) or received (negative) if position was closed now.",
              "type": "string"
            },
            "entry_price_base": {
              "description": "Entry price",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "funding_fee_collateral": {
              "description": "The ongoing fee paid (and earned!) between positions to incentivize keeping longs and shorts in balance which in turn reduces risk for LPs\n\nThis value is the current balance, not a historical record of each payment",
              "type": "string"
            },
            "funding_fee_usd": {
              "description": "USD expression of [Self::funding_fee_collateral] using cost-basis calculation.",
              "type": "string"
            },
            "id": {
              "description": "Unique ID",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionId"
                }
              ]
            },
            "leverage": {
              "description": "Current leverage\n\nThis is impacted by fees and price exposure",
              "allOf": [
                {
                  "$ref": "#/definitions/LeverageToBase"
                }
              ]
            },
            "liquidation_margin": {
              "description": "The liquidation margin set aside on this position",
              "allOf": [
                {
                  "$ref": "#/definitions/LiquidationMargin"
                }
              ]
            },
            "liquidation_price_base": {
              "description": "Price at which liquidation will occur",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "liquifunded_at": {
              "description": "When the position was last liquifunded",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "max_gains_in_quote": {
              "description": "Maximum gains, in terms of quote, the trader can achieve",
              "allOf": [
                {
                  "$ref": "#/definitions/MaxGainsInQuote"
                }
              ]
            },
            "next_liquifunding": {
              "description": "When the next liquifunding is scheduled",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "notional_size": {
              "description": "Notional size of the position",
              "type": "string"
            },
            "notional_size_in_collateral": {
              "description": "Notional size converted to collateral at the current price",
              "type": "string"
            },
            "owner": {
              "description": "Owner",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pnl_collateral": {
              "description": "Unrealized PnL on this position, in terms of collateral.",
              "type": "string"
            },
            "pnl_usd": {
              "description": "Unrealized PnL on this position, in USD, using cost-basis analysis.",
              "type": "string"
            },
            "position_size_base": {
              "description": "The size of the position in terms of the base asset.\n\nNote that this is not a simple conversion from notional size. Instead, this needs to account for the off-by-one leverage that occurs in collateral-is-base markets.",
              "type": "string"
            },
            "position_size_usd": {
              "description": "Convert [Self::position_size_base] into USD at the current exchange rate.",
              "type": "string"
            },
            "price_point_created_at": {
              "description": "Price point used for creating this position",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stop_loss_override": {
              "description": "Stop loss price set by the trader",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "take_profit_override": {
              "description": "Take profit price set by the trader",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "take_profit_price_base": {
              "description": "Price at which trader will achieve maximum gains and take all counter collateral.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "trading_fee_collateral": {
              "description": "The one-time fee paid when opening or updating a position\n\nThis value is the current balance, including all updates",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "trading_fee_usd": {
              "description": "USD expression of [Self::trading_fee_collateral] using cost-basis calculation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "price_would_trigger": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PriceWouldTriggerResp",
      "description": "Would a price update trigger a liquidation/take profit/etc?",
      "type": "object",
      "required": [
        "would_trigger"
      ],
      "properties": {
        "would_trigger": {
          "description": "Would a price update trigger a liquidation/take profit/etc?",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "spot_price": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PricePoint",
      "description": "All prices in the protocol for a given point in time.\n\nThis includes extra information necessary for performing all conversions, such as the [MarketType].",
      "type": "object",
      "required": [
        "is_notional_usd",
        "market_type",
        "price_base",
        "price_notional",
        "price_usd",
        "timestamp"
      ],
      "properties": {
        "is_notional_usd": {
          "description": "Is the notional asset USD?\n\nUsed for avoiding lossy conversions to USD when they aren't needed.\n\nWe do not need to track if the collateral asset is USD, since USD can never be used as collateral directly. Instead, stablecoins would be used, in which case an explicit price to USD is always needed.",
          "type": "boolean"
        },
        "market_type": {
          "description": "Indicates if this market uses collateral as base or quote, needed for price conversions.",
          "allOf": [
            {
              "$ref": "#/definitions/MarketType"
            }
          ]
        },
        "price_base": {
          "description": "Price of the base asset in terms of the quote.",
          "allOf": [
            {
              "$ref": "#/definitions/PriceBaseInQuote"
            }
          ]
        },
        "price_notional": {
          "description": "Price as used internally by the protocol, in terms of collateral and notional.\n\nThis is generally less useful for external consumers, where [PricePoint::price_usd] and [PricePoint::price_base] are used.",
          "allOf": [
            {
              "$ref": "#/definitions/Price"
            }
          ]
        },
        "price_usd": {
          "description": "Price of the collateral asset in terms of USD.\n\nThis is generally used for reporting of values like PnL and trade volume.",
          "allOf": [
            {
              "$ref": "#/definitions/PriceCollateralInUsd"
            }
          ]
        },
        "publish_time": {
          "description": "Latest price publish time for the feeds composing the price, if available\n\nThis field will always be empty since implementation of deferred execution.",
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "publish_time_usd": {
          "description": "Latest price publish time for the feeds composing the price_usd, if available\n\nThis field will always be empty since implementation of deferred execution.",
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "timestamp": {
          "description": "Publish time of this price point.\n\nBefore deferred execution, this was the block time when the field was added. Since deferred execution, this is a calculated value based on the publish times of individual feeds.",
          "allOf": [
            {
              "$ref": "#/definitions/Timestamp"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "MarketType": {
          "description": "Whether the collateral asset is the same as the quote or base asset.",
          "oneOf": [
            {
              "description": "A market where the collateral is the quote asset",
              "type": "string",
              "enum": [
                "collateral_is_quote"
              ]
            },
            {
              "description": "A market where the collateral is the base asset",
              "type": "string",
              "enum": [
                "collateral_is_base"
              ]
            }
          ]
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "Price": {
          "description": "The price of the pair as used internally by the protocol, given as `collateral / notional`.",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PriceCollateralInUsd": {
          "description": "PriceBaseInQuote converted to USD",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        }
      }
    },
    "spot_price_history": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SpotPriceHistoryResp",
      "description": "Response for [QueryMsg::SpotPriceHistory]",
      "type": "object",
      "required": [
        "price_points"
      ],
      "properties": {
        "price_points": {
          "description": "list of historical price points",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PricePoint"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "MarketType": {
          "description": "Whether the collateral asset is the same as the quote or base asset.",
          "oneOf": [
            {
              "description": "A market where the collateral is the quote asset",
              "type": "string",
              "enum": [
                "collateral_is_quote"
              ]
            },
            {
              "description": "A market where the collateral is the base asset",
              "type": "string",
              "enum": [
                "collateral_is_base"
              ]
            }
          ]
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "Price": {
          "description": "The price of the pair as used internally by the protocol, given as `collateral / notional`.",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PriceCollateralInUsd": {
          "description": "PriceBaseInQuote converted to USD",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "PricePoint": {
          "description": "All prices in the protocol for a given point in time.\n\nThis includes extra information necessary for performing all conversions, such as the [MarketType].",
          "type": "object",
          "required": [
            "is_notional_usd",
            "market_type",
            "price_base",
            "price_notional",
            "price_usd",
            "timestamp"
          ],
          "properties": {
            "is_notional_usd": {
              "description": "Is the notional asset USD?\n\nUsed for avoiding lossy conversions to USD when they aren't needed.\n\nWe do not need to track if the collateral asset is USD, since USD can never be used as collateral directly. Instead, stablecoins would be used, in which case an explicit price to USD is always needed.",
              "type": "boolean"
            },
            "market_type": {
              "description": "Indicates if this market uses collateral as base or quote, needed for price conversions.",
              "allOf": [
                {
                  "$ref": "#/definitions/MarketType"
                }
              ]
            },
            "price_base": {
              "description": "Price of the base asset in terms of the quote.",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                }
              ]
            },
            "price_notional": {
              "description": "Price as used internally by the protocol, in terms of collateral and notional.\n\nThis is generally less useful for external consumers, where [PricePoint::price_usd] and [PricePoint::price_base] are used.",
              "allOf": [
                {
                  "$ref": "#/definitions/Price"
                }
              ]
            },
            "price_usd": {
              "description": "Price of the collateral asset in terms of USD.\n\nThis is generally used for reporting of values like PnL and trade volume.",
              "allOf": [
                {
                  "$ref": "#/definitions/PriceCollateralInUsd"
                }
              ]
            },
            "publish_time": {
              "description": "Latest price publish time for the feeds composing the price, if available\n\nThis field will always be empty since implementation of deferred execution.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "publish_time_usd": {
              "description": "Latest price publish time for the feeds composing the price_usd, if available\n\nThis field will always be empty since implementation of deferred execution.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "description": "Publish time of this price point.\n\nBefore deferred execution, this was the block time when the field was added. Since deferred execution, this is a calculated value based on the publish times of individual feeds.",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        }
      }
    },
    "status": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StatusResp",
      "description": "Overall market status information\n\nReturned from [QueryMsg::Status]",
      "type": "object",
      "required": [
        "base",
        "borrow_fee",
        "borrow_fee_lp",
        "borrow_fee_xlp",
        "collateral",
        "config",
        "deferred_execution_items",
        "delta_neutrality_fee_fund",
        "fees",
        "instant_delta_neutrality_fee_value",
        "liquidity",
        "long_funding",
        "long_notional",
        "long_usd",
        "market_id",
        "market_type",
        "quote",
        "short_funding",
        "short_notional",
        "short_usd"
      ],
      "properties": {
        "base": {
          "description": "Base asset",
          "type": "string"
        },
        "borrow_fee": {
          "description": "Overall borrow fee rate (annualized), combining LP and xLP",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "borrow_fee_lp": {
          "description": "LP component of [Self::borrow_fee]",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "borrow_fee_xlp": {
          "description": "xLP component of [Self::borrow_fee]",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "collateral": {
          "description": "The asset used for collateral within the system",
          "allOf": [
            {
              "$ref": "#/definitions/Token"
            }
          ]
        },
        "config": {
          "description": "Config for this market",
          "allOf": [
            {
              "$ref": "#/definitions/Config"
            }
          ]
        },
        "deferred_execution_items": {
          "description": "Number of work items sitting in the deferred execution queue",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "delta_neutrality_fee_fund": {
          "description": "Amount of collateral in the delta neutrality fee fund.",
          "allOf": [
            {
              "$ref": "#/definitions/Collateral"
            }
          ]
        },
        "fees": {
          "description": "Fees held by the market contract",
          "allOf": [
            {
              "$ref": "#/definitions/Fees"
            }
          ]
        },
        "instant_delta_neutrality_fee_value": {
          "description": "Instant delta neutrality fee value\n\nThis is based on net notional and the sensitivity parameter",
          "type": "string"
        },
        "last_crank_completed": {
          "description": "Timestamp of the last completed crank",
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "last_processed_deferred_exec_id": {
          "description": "Last processed deferred execution ID, if any",
          "anyOf": [
            {
              "$ref": "#/definitions/DeferredExecId"
            },
            {
              "type": "null"
            }
          ]
        },
        "liquidity": {
          "description": "Current status of the liquidity pool",
          "allOf": [
            {
              "$ref": "#/definitions/LiquidityStats"
            }
          ]
        },
        "long_funding": {
          "description": "Long funding rate (annualized)",
          "type": "string"
        },
        "long_notional": {
          "description": "Total long interest, given in the notional asset.",
          "allOf": [
            {
              "$ref": "#/definitions/Notional"
            }
          ]
        },
        "long_usd": {
          "description": "Total long interest, given in USD, converted at the current exchange rate.",
          "allOf": [
            {
              "$ref": "#/definitions/Usd"
            }
          ]
        },
        "market_id": {
          "description": "This market's identifier",
          "allOf": [
            {
              "$ref": "#/definitions/MarketId"
            }
          ]
        },
        "market_type": {
          "description": "Type of market",
          "allOf": [
            {
              "$ref": "#/definitions/MarketType"
            }
          ]
        },
        "newest_deferred_execution": {
          "description": "Latest deferred execution price timestamp needed",
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "next_crank": {
          "description": "Next bit of crank work available, if any",
          "anyOf": [
            {
              "$ref": "#/definitions/CrankWorkInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "next_deferred_execution": {
          "description": "Earliest deferred execution price timestamp needed",
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "next_liquifunding": {
          "description": "Next liquifunding work item timestamp",
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "quote": {
          "description": "Quote asset",
          "type": "string"
        },
        "short_funding": {
          "description": "Short funding rate (annualized)",
          "type": "string"
        },
        "short_notional": {
          "description": "Total short interest, given in the notional asset.",
          "allOf": [
            {
              "$ref": "#/definitions/Notional"
            }
          ]
        },
        "short_usd": {
          "description": "Total short interest, given in USD, converted at the current exchange rate.",
          "allOf": [
            {
              "$ref": "#/definitions/Usd"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Config": {
          "description": "Configuration info for the vAMM Set by admin-only Since this tends to cross the message boundary all the numeric types are u32 or lower helper functions are available where more bits are needed",
          "type": "object",
          "required": [
            "borrow_fee_rate_max_annualized",
            "borrow_fee_rate_min_annualized",
            "borrow_fee_sensitivity",
            "carry_leverage",
            "crank_execs",
            "crank_fee_charged",
            "crank_fee_reward",
            "delta_neutrality_fee_cap",
            "delta_neutrality_fee_sensitivity",
            "delta_neutrality_fee_tax",
            "funding_rate_max_annualized",
            "funding_rate_sensitivity",
            "liquifunding_delay_seconds",
            "max_leverage",
            "max_xlp_rewards_multiplier",
            "min_xlp_rewards_multiplier",
            "minimum_deposit_usd",
            "mute_events",
            "protocol_tax",
            "spot_price",
            "target_utilization",
            "trading_fee_counter_collateral",
            "trading_fee_notional_size",
            "unstake_period_seconds"
          ],
          "properties": {
            "borrow_fee_rate_max_annualized": {
              "description": "The maximum annualized rate for borrow fee payments",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "borrow_fee_rate_min_annualized": {
              "description": "The minimum annualized rate for borrow fee payments",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "borrow_fee_sensitivity": {
              "description": "Borrow fee sensitivity parameter.\n\nSee [section 5.5 of the whitepaper](https://www.notion.so/levana-protocol/Levana-Well-funded-Perpetuals-Whitepaper-9805a6eba56d429b839f5551dbb65c40#295f9f2689e74ccab16ca28177eb32cb).",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "carry_leverage": {
              "description": "Needed to ensure financial model is balanced\n\nMust be at most 1 less than the [Config::max_leverage]",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "crank_execs": {
              "description": "default number of crank exeuctions to do when none specified",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "crank_fee_charged": {
              "description": "The crank fee to be paid into the system, in collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "crank_fee_reward": {
              "description": "The crank fee to be sent to crankers, in collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "crank_fee_surcharge": {
              "description": "The crank surcharge charged for every 10 items in the deferred execution queue.\n\nThis is intended to create backpressure in times of high congestion.\n\nFor every 10 items in the deferred execution queue, this amount is added to the crank fee charged on performing a deferred execution message.\n\nThis is only charged while adding new items to the queue, not when performing ongoing tasks like liquifunding or liquidations.",
              "default": "0.08",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "delta_neutrality_fee_cap": {
              "description": "Delta neutrality fee cap parameter, given as a percentage",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "delta_neutrality_fee_sensitivity": {
              "description": "Delta neutrality fee sensitivity parameter.",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "delta_neutrality_fee_tax": {
              "description": "Proportion of delta neutrality inflows that are sent to the protocol.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "disable_position_nft_exec": {
              "description": "Disable the ability to proxy CW721 execution messages for positions. Even if this is true, queries will still work as usual.",
              "default": false,
              "type": "boolean"
            },
            "exposure_margin_ratio": {
              "description": "Ratio of notional size used for the exposure component of the liquidation margin.",
              "default": "0.005",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "funding_rate_max_annualized": {
              "description": "The maximum annualized rate for a funding payment",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "funding_rate_sensitivity": {
              "description": "Impacts how much the funding rate changes in response to net notional changes.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "limit_order_fee": {
              "description": "Just for historical reasons/migrations",
              "anyOf": [
                {
                  "$ref": "#/definitions/Collateral"
                },
                {
                  "type": "null"
                }
              ]
            },
            "liquidity_cooldown_seconds": {
              "description": "The liquidity cooldown period.\n\nAfter depositing new funds into the market, liquidity providers will have a period of time where they cannot withdraw their funds. This is intended to prevent an MEV attack where someone can reorder transactions to extract fees from traders without taking on any impairment risk.\n\nThis protection is only triggered by deposit of new funds; reinvesting existing yield does not introduce a cooldown.\n\nWhile the cooldown is in place, providers are prevented from either withdrawing liquidity or transferring their LP and xLP tokens.\n\nFor migration purposes, this value defaults to 0, meaning no cooldown period.",
              "default": 0,
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "liquifunding_delay_fuzz_seconds": {
              "description": "The liquifunding delay fuzz factor, in seconds.\n\nUp to how many seconds will we perform a liquifunding early. This will be part of a semi-randomly generated value and will allow us to schedule liquifundings arbitrarily to smooth out spikes in traffic.",
              "default": 3600,
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "liquifunding_delay_seconds": {
              "description": "Delay between liquifundings, in seconds",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "max_leverage": {
              "description": "The maximum allowed leverage when opening a position",
              "type": "string"
            },
            "max_liquidity": {
              "description": "The maximum amount of liquidity that can be deposited into the market.",
              "default": {
                "unlimited": {}
              },
              "allOf": [
                {
                  "$ref": "#/definitions/MaxLiquidity"
                }
              ]
            },
            "max_xlp_rewards_multiplier": {
              "description": "Maximum multiplier for xLP versus LP borrow fee shares.\n\nFor example, if this number is 5, then as liquidity in the protocol approaches 100% in LP and 0% in xLP, any xLP token will receive 5x the rewards of an LP token.",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "min_xlp_rewards_multiplier": {
              "description": "Minimum counterpoint to [Config::max_xlp_rewards_multiplier]",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "minimum_deposit_usd": {
              "description": "Minimum deposit collateral, given in USD",
              "allOf": [
                {
                  "$ref": "#/definitions/Usd"
                }
              ]
            },
            "mute_events": {
              "description": "Do not emit events (default is false, events *will* be emitted)",
              "type": "boolean"
            },
            "price_update_too_old_seconds": {
              "description": "Just for historical reasons/migrations",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "protocol_tax": {
              "description": "The percentage of fees that are taken for the protocol",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "spot_price": {
              "description": "The spot price config for this market",
              "allOf": [
                {
                  "$ref": "#/definitions/SpotPriceConfig"
                }
              ]
            },
            "staleness_seconds": {
              "description": "Just for historical reasons/migrations",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "target_utilization": {
              "description": "Target utilization ratio liquidity, given as a ratio. (Must be between 0 and 1).",
              "allOf": [
                {
                  "$ref": "#/definitions/NonZero decimal"
                }
              ]
            },
            "trading_fee_counter_collateral": {
              "description": "The fee to open a position, as a percentage of the counter-side collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "trading_fee_notional_size": {
              "description": "The fee to open a position, as a percentage of the notional size",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "unpend_limit": {
              "description": "Just for historical reasons/migrations",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "unstake_period_seconds": {
              "description": "How long it takes to unstake xLP tokens into LP tokens, in seconds",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "CrankWorkInfo": {
          "description": "What work is currently available for the crank.",
          "oneOf": [
            {
              "description": "Closing all open positions",
              "type": "object",
              "required": [
                "close_all_positions"
              ],
              "properties": {
                "close_all_positions": {
                  "type": "object",
                  "required": [
                    "position"
                  ],
                  "properties": {
                    "position": {
                      "description": "Next position to be closed",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Resetting all LP balances to 0 after all liquidity is drained",
              "type": "object",
              "required": [
                "reset_lp_balances"
              ],
              "properties": {
                "reset_lp_balances": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Liquifund a position",
              "type": "object",
              "required": [
                "liquifunding"
              ],
              "properties": {
                "liquifunding": {
                  "type": "object",
                  "required": [
                    "position"
                  ],
                  "properties": {
                    "position": {
                      "description": "Next position to be liquifunded",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Liquidate a position.\n\nIncludes max gains, take profit, and stop loss.",
              "type": "object",
              "required": [
                "liquidation"
              ],
              "properties": {
                "liquidation": {
                  "type": "object",
                  "required": [
                    "liquidation_reason",
                    "position"
                  ],
                  "properties": {
                    "liquidation_reason": {
                      "description": "Reason for the liquidation",
                      "allOf": [
                        {
                          "$ref": "#/definitions/LiquidationReason"
                        }
                      ]
                    },
                    "position": {
                      "description": "Position to liquidate",
                      "allOf": [
                        {
                          "$ref": "#/definitions/PositionId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Deferred execution (open/update/closed) can be executed.",
              "type": "object",
              "required": [
                "deferred_exec"
              ],
              "properties": {
                "deferred_exec": {
                  "type": "object",
                  "required": [
                    "deferred_exec_id",
                    "target"
                  ],
                  "properties": {
                    "deferred_exec_id": {
                      "description": "ID to be processed",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DeferredExecId"
                        }
                      ]
                    },
                    "target": {
                      "description": "Target of the action",
                      "allOf": [
                        {
                          "$ref": "#/definitions/DeferredExecTarget"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Limit order can be opened",
              "type": "object",
              "required": [
                "limit_order"
              ],
              "properties": {
                "limit_order": {
                  "type": "object",
                  "required": [
                    "order_id"
                  ],
                  "properties": {
                    "order_id": {
                      "description": "ID of the order to be opened",
                      "allOf": [
                        {
                          "$ref": "#/definitions/OrderId"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Finished all processing for a given price update",
              "type": "object",
              "required": [
                "completed"
              ],
              "properties": {
                "completed": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "DeferredExecId": {
          "description": "A unique numeric ID for each deferred execution in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "DeferredExecTarget": {
          "description": "What entity within the system will be affected by this.",
          "oneOf": [
            {
              "description": "For open positions or limit orders, no ID exists yet",
              "type": "string",
              "enum": [
                "does_not_exist"
              ]
            },
            {
              "description": "Modifying an existing position",
              "type": "object",
              "required": [
                "position"
              ],
              "properties": {
                "position": {
                  "$ref": "#/definitions/PositionId"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Modifying an existing limit order",
              "type": "object",
              "required": [
                "order"
              ],
              "properties": {
                "order": {
                  "$ref": "#/definitions/OrderId"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Fees": {
          "description": "Fees held within the market contract.",
          "type": "object",
          "required": [
            "crank",
            "protocol",
            "wallets"
          ],
          "properties": {
            "crank": {
              "description": "Crank fees collected and waiting to be allocated to crankers.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "protocol": {
              "description": "Fees available for the protocol overall to withdraw.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "wallets": {
              "description": "Fees available for individual wallets to withdraw.",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Identifier": {
          "type": "string"
        },
        "LiquidationReason": {
          "description": "Reason why a position was liquidated",
          "oneOf": [
            {
              "description": "True liquidation: insufficient funds in active collateral.",
              "type": "string",
              "enum": [
                "liquidated"
              ]
            },
            {
              "description": "Maximum gains were achieved.",
              "type": "string",
              "enum": [
                "max_gains"
              ]
            },
            {
              "description": "Stop loss price override was triggered.",
              "type": "string",
              "enum": [
                "stop_loss"
              ]
            },
            {
              "description": "Specifically take profit override, not max gains.",
              "type": "string",
              "enum": [
                "take_profit"
              ]
            }
          ]
        },
        "LiquidityStats": {
          "description": "Protocol wide stats on liquidity",
          "type": "object",
          "required": [
            "locked",
            "total_lp",
            "total_xlp",
            "unlocked"
          ],
          "properties": {
            "locked": {
              "description": "Collateral locked as counter collateral in the protocol",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "total_lp": {
              "description": "Total number of LP tokens",
              "allOf": [
                {
                  "$ref": "#/definitions/LpToken"
                }
              ]
            },
            "total_xlp": {
              "description": "Total number of xLP tokens",
              "allOf": [
                {
                  "$ref": "#/definitions/LpToken"
                }
              ]
            },
            "unlocked": {
              "description": "Total amount of collateral available to be used as liquidity",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "LpToken": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "MarketId": {
          "type": "string",
          "format": "market-id"
        },
        "MarketType": {
          "description": "Whether the collateral asset is the same as the quote or base asset.",
          "oneOf": [
            {
              "description": "A market where the collateral is the quote asset",
              "type": "string",
              "enum": [
                "collateral_is_quote"
              ]
            },
            {
              "description": "A market where the collateral is the base asset",
              "type": "string",
              "enum": [
                "collateral_is_base"
              ]
            }
          ]
        },
        "MaxLiquidity": {
          "description": "Maximum liquidity for deposit.\n\nNote that this limit can be exceeded due to changes in collateral asset price or impairment.",
          "oneOf": [
            {
              "description": "No bounds on how much liquidity can be deposited.",
              "type": "object",
              "required": [
                "unlimited"
              ],
              "properties": {
                "unlimited": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Only allow the given amount in USD.\n\nThe exchange rate at time of deposit will be used.",
              "type": "object",
              "required": [
                "usd"
              ],
              "properties": {
                "usd": {
                  "type": "object",
                  "required": [
                    "amount"
                  ],
                  "properties": {
                    "amount": {
                      "description": "Amount in USD",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "Notional": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "OrderId": {
          "description": "A unique numeric ID for each order in the protocol.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PythConfig": {
          "description": "Configuration for pyth",
          "type": "object",
          "required": [
            "contract_address",
            "network"
          ],
          "properties": {
            "contract_address": {
              "description": "The address of the pyth oracle contract",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "network": {
              "description": "Which network to use for the price service This isn't used for any internal logic, but clients must use the appropriate price service endpoint to match this",
              "allOf": [
                {
                  "$ref": "#/definitions/PythPriceServiceNetwork"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PythPriceServiceNetwork": {
          "description": "Which network to use for the price service",
          "oneOf": [
            {
              "description": "Stable CosmWasm\n\nFrom <https://pyth.network/developers/price-feed-ids#cosmwasm-stable>",
              "type": "string",
              "enum": [
                "stable"
              ]
            },
            {
              "description": "Edge CosmWasm\n\nFrom <https://pyth.network/developers/price-feed-ids#cosmwasm-edge>",
              "type": "string",
              "enum": [
                "edge"
              ]
            }
          ]
        },
        "RawAddr": {
          "description": "A raw address passed in via JSON.\n\nThe purpose of this newtype wrapper is to make it clear at the type level if a parameter is an address, and ensure that we go through a proper validation step when using it.",
          "type": "string"
        },
        "SpotPriceConfig": {
          "description": "Spot price config",
          "oneOf": [
            {
              "description": "Manual spot price",
              "type": "object",
              "required": [
                "manual"
              ],
              "properties": {
                "manual": {
                  "type": "object",
                  "required": [
                    "admin"
                  ],
                  "properties": {
                    "admin": {
                      "description": "The admin address for manual spot price updates",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "External oracle",
              "type": "object",
              "required": [
                "oracle"
              ],
              "properties": {
                "oracle": {
                  "type": "object",
                  "required": [
                    "feeds",
                    "feeds_usd"
                  ],
                  "properties": {
                    "feeds": {
                      "description": "sequence of spot price feeds which are composed to generate a single spot price",
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/SpotPriceFeed"
                      }
                    },
                    "feeds_usd": {
                      "description": "if necessary, sequence of spot price feeds which are composed to generate a single USD spot price",
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/SpotPriceFeed"
                      }
                    },
                    "pyth": {
                      "description": "Pyth configuration, required on chains that use pyth feeds",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/PythConfig"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "stride": {
                      "description": "Stride configuration, required on chains that use stride",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/StrideConfig"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "volatile_diff_seconds": {
                      "description": "How many seconds the publish time of volatile feeds are allowed to diverge from each other\n\nAn attacker can, in theory, selectively choose two different publish times for a pair of assets and manipulate the combined price. This value allows us to say that the publish time cannot diverge by too much. As opposed to age tolerance, this allows for latency in getting transactions to land on-chain after publish time, and therefore can be a much tighter value.\n\nBy default, we use 5 seconds.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "SpotPriceFeed": {
          "description": "An individual feed used to compose a final spot price",
          "type": "object",
          "required": [
            "data",
            "inverted"
          ],
          "properties": {
            "data": {
              "description": "The data for this price feed",
              "allOf": [
                {
                  "$ref": "#/definitions/SpotPriceFeedData"
                }
              ]
            },
            "inverted": {
              "description": "is this price feed inverted",
              "type": "boolean"
            },
            "volatile": {
              "description": "Is this a volatile feed?\n\nVolatile feeds are expected to have frequent and significant price swings. By contrast, a non-volatile feed may be a redemption rate, which will slowly update over time. The purpose of volatility is to determine whether the publich time for a composite spot price should include the individual feed or not. For example, if we have a market like StakedETH_BTC, we would have a StakedETH redemption rate, the price of ETH, and the price of BTC. We'd mark ETH and BTC as volatile, and the redemption rate as non-volatile. Then the publish time would be the earlier of the ETH and BTC publish time.\n\nThis field is optional. If omitted, it will use a default based on the `data` field, specifically: Pyth and Sei variants are considered volatile, Constant, Stride, and Simple are non-volatile.",
              "type": [
                "boolean",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "SpotPriceFeedData": {
          "description": "The data for an individual spot price feed",
          "oneOf": [
            {
              "description": "Hardcoded value",
              "type": "object",
              "required": [
                "constant"
              ],
              "properties": {
                "constant": {
                  "type": "object",
                  "required": [
                    "price"
                  ],
                  "properties": {
                    "price": {
                      "description": "The constant price",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NonZero decimal"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Pyth price feeds",
              "type": "object",
              "required": [
                "pyth"
              ],
              "properties": {
                "pyth": {
                  "type": "object",
                  "required": [
                    "age_tolerance_seconds",
                    "id"
                  ],
                  "properties": {
                    "age_tolerance_seconds": {
                      "description": "price age tolerance, in seconds\n\nWe thought about removing this parameter when moving to deferred execution. However, this would leave open a potential attack vector of opening limit orders or positions, shutting down price updates, and then selectively replaying old price updates for favorable triggers.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "id": {
                      "description": "The identifier on pyth",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Identifier"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stride liquid staking",
              "type": "object",
              "required": [
                "stride"
              ],
              "properties": {
                "stride": {
                  "type": "object",
                  "required": [
                    "age_tolerance_seconds",
                    "denom"
                  ],
                  "properties": {
                    "age_tolerance_seconds": {
                      "description": "price age tolerance, in seconds",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "denom": {
                      "description": "The IBC denom for the asset",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native oracle module on the sei chain",
              "type": "object",
              "required": [
                "sei"
              ],
              "properties": {
                "sei": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "description": "The denom to use",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Simple contract with a QueryMsg::Price call",
              "type": "object",
              "required": [
                "simple"
              ],
              "properties": {
                "simple": {
                  "type": "object",
                  "required": [
                    "age_tolerance_seconds",
                    "contract"
                  ],
                  "properties": {
                    "age_tolerance_seconds": {
                      "description": "price age tolerance, in seconds",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "contract": {
                      "description": "The contract to use",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "StrideConfig": {
          "description": "Configuration for stride",
          "type": "object",
          "required": [
            "contract_address"
          ],
          "properties": {
            "contract_address": {
              "description": "The address of the redemption rate contract",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Token": {
          "description": "The overall ideas of the Token API are: 1. use the Number type, not u128 or Uint128 2. abstract over the Cw20/Native variants\n\nAt the end of the day, call transfer/query with the same business logic as contract math and don't worry at all about conversions or addresses/denoms",
          "oneOf": [
            {
              "description": "An asset controlled by a CW20 token.",
              "type": "object",
              "required": [
                "cw20"
              ],
              "properties": {
                "cw20": {
                  "type": "object",
                  "required": [
                    "addr",
                    "decimal_places"
                  ],
                  "properties": {
                    "addr": {
                      "description": "Address of the contract",
                      "allOf": [
                        {
                          "$ref": "#/definitions/RawAddr"
                        }
                      ]
                    },
                    "decimal_places": {
                      "description": "Decimals places used by the contract",
                      "type": "integer",
                      "format": "uint8",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native coin on the blockchain",
              "type": "object",
              "required": [
                "native"
              ],
              "properties": {
                "native": {
                  "type": "object",
                  "required": [
                    "decimal_places",
                    "denom"
                  ],
                  "properties": {
                    "decimal_places": {
                      "description": "Decimal places used by the asset",
                      "type": "integer",
                      "format": "uint8",
                      "minimum": 0.0
                    },
                    "denom": {
                      "description": "Native coin denom string",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "trade_history_summary": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TradeHistorySummary",
      "description": "The summary for trade history",
      "type": "object",
      "required": [
        "realized_pnl",
        "trade_volume"
      ],
      "properties": {
        "realized_pnl": {
          "description": "Given in usd",
          "type": "string"
        },
        "trade_volume": {
          "description": "Given in usd",
          "allOf": [
            {
              "$ref": "#/definitions/Usd"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "trader_action_history": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TraderActionHistoryResp",
      "description": "Response for [QueryMsg::TraderActionHistory]",
      "type": "object",
      "required": [
        "actions"
      ],
      "properties": {
        "actions": {
          "description": "list of position actions that this trader performed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PositionAction"
          }
        },
        "next_start_after": {
          "description": "Next start_after value to continue pagination\n\nNone means no more pagination",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Collateral": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "LeverageToBase": {
          "description": "The absolute leverage for a position, in terms of the base asset.\n\nNote that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        },
        "MaxGainsInQuote": {
          "type": "string",
          "format": "leverage"
        },
        "NonZero decimal": {
          "type": "string",
          "format": "non-zero"
        },
        "PositionAction": {
          "description": "A distinct position history action",
          "type": "object",
          "required": [
            "collateral",
            "kind",
            "timestamp"
          ],
          "properties": {
            "collateral": {
              "description": "the amount of collateral at the time of the action",
              "allOf": [
                {
                  "$ref": "#/definitions/Collateral"
                }
              ]
            },
            "delta_neutrality_fee": {
              "description": "The delta neutrality fee paid (or, if negative, received) in USD",
              "type": [
                "string",
                "null"
              ]
            },
            "id": {
              "description": "ID of the position impacted\n\nFor ease of migration, we allow for a missing position ID.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PositionId"
                },
                {
                  "type": "null"
                }
              ]
            },
            "kind": {
              "description": "Kind of action taken by the trader",
              "allOf": [
                {
                  "$ref": "#/definitions/PositionActionKind"
                }
              ]
            },
            "leverage": {
              "description": "Leverage of the position at the time of the action, if relevant",
              "anyOf": [
                {
                  "$ref": "#/definitions/LeverageToBase"
                },
                {
                  "type": "null"
                }
              ]
            },
            "max_gains": {
              "description": "max gains in quote",
              "anyOf": [
                {
                  "$ref": "#/definitions/MaxGainsInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "new_owner": {
              "description": "If this is a position transfer, the new owner.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "old_owner": {
              "description": "If this is a position transfer, the previous owner.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stop_loss_override": {
              "description": "The stop loss override, if set.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "take_profit_override": {
              "description": "The take profit override, if set.",
              "anyOf": [
                {
                  "$ref": "#/definitions/PriceBaseInQuote"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "description": "Timestamp when the action occurred",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "trade_fee": {
              "description": "the trade fee in USD",
              "anyOf": [
                {
                  "$ref": "#/definitions/Usd"
                },
                {
                  "type": "null"
                }
              ]
            },
            "transfer_collateral": {
              "description": "The amount of collateral transferred to or from the trader",
              "default": "0",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "PositionActionKind": {
          "description": "Action taken by trader for a [PositionAction]",
          "oneOf": [
            {
              "description": "Open a new position",
              "type": "string",
              "enum": [
                "open"
              ]
            },
            {
              "description": "Updated an existing position",
              "type": "string",
              "enum": [
                "update"
              ]
            },
            {
              "description": "Close a position",
              "type": "string",
              "enum": [
                "close"
              ]
            },
            {
              "description": "Position was transferred between wallets",
              "type": "string",
              "enum": [
                "transfer"
              ]
            }
          ]
        },
        "PositionId": {
          "description": "PositionId",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "PriceBaseInQuote": {
          "description": "The price of the currency pair, given as `quote / base`, e.g. \"20,000 USD per BTC\".",
          "allOf": [
            {
              "$ref": "#/definitions/NonZero decimal"
            }
          ]
        },
        "Timestamp": {
          "description": "Essentially a newtype wrapper for [Timestamp] providing additional impls.\n\nInternal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "Usd": {
          "description": "Unsigned value",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal256"
            }
          ]
        }
      }
    },
    "version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractVersion",
      "type": "object",
      "required": [
        "contract",
        "version"
      ],
      "properties": {
        "contract": {
          "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
          "type": "string"
        },
        "version": {
          "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
